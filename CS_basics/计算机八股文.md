# 计算机八股文



## 一、 语言基础

### 1. 智能指针（4种）

头文件：<memory>。

> 智能指针的作用是方便程序员分配内存时忘记释放内存，造成内存泄漏的发生。

智能指针的原理是：本身是一个**类**，然后在析构的时候，会自动释放资源。函数结束时，自动释放内存空间。

#### 1.1 auto_ptr(已弃用)

采用所有权方式，已经被unique_ptr所取代，原因是有内存崩溃的可能。

p1指向一个指针，然后p2指向p1，p1指针所有权已被剥夺，但是此时编译器不会报错，运行时才会报错，也就是内存泄漏；



#### 1.2 unique_ptr（独占式）

本质上也是一种所有权方式，只能有一个unique_ptr指向一个内存。

当第二个指针指向相同内存时候会报错。

1.3 shared_ptr（强引用）

sp，会有一个计数器，允许多个指针指向同一个内存，释放时计数器-1，如果计数器归零，就会释放内存。

#### 1.4 weak_ptr（弱引用）

wp主要是辅助sp，并不会添加计数器，但是也不能改变指向的值，可以解决是sp相互引用的死锁问题（将其中一个sp改为wp）。

#### 1.5 代码示例

```c++
#include <memory>
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

int main() {
	unique_ptr<int> up1(new int(10));
	unique_ptr<int> up2;
	cout << *up1 << endl;
	// up2 = up1; // 会报错,无法这样赋值。

	shared_ptr<int> sp1(new int(20));
	shared_ptr<int> sp2;
	sp2 = sp1;
	cout << *sp2 << " " << *sp1 << endl;
	cout << "sp1计数器: " << sp1.use_count() << endl;
	
	weak_ptr<int> wp1 = sp1;
	cout << "weak_ptr不影响计数器（弱引用）" << *(wp1.lock()) << endl;
	cout << "sp1计数器: " << sp1.use_count() << endl;

	system("pause");
	return 0;
}
```

输出结果：

![image-20230102233320457](C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20230102233320457.png)





### 2. 内存空间

**堆：** 程序员分配的内存空间，使用 new， delete 等关键字来分配，但需要注意的是需要清理，并不能自动清理，否则会出现问题；

**栈：** 程序自己分配的内存空间，主要存储局部变量；

**全局/静态变量区：** 存储全局变量和静态变量；

**常量区：** 存储常量；

**代码区：** 存储二进制代码。



### 3. 指针传递和引用传递

#### 3.1 指针传递

本质上是一种值传递，传递得是一个地址，进入函数时，对这个地址做改变不会影响原有地址；但如果对地址指向的内存进行改变，则会影响该内存的东西；

```c++
void fun(int *a, int* b)
{
	swap(a, b);
//	int tmp = *a;
//	*a = *b;
//	*b = tmp;
}
```

例如本例中，swap **a** 和 **b** 的**地址**，但返回主函数以后，a 和 b 的地址并没有改变，因为相当于对fun内的临时变量做了改变，并不影响实参。

但如果把注释的内容取消，则会对 a 和 b **指向的内容** 作出改变。



#### 3.2 引用传递

引用本身就是那块地址的别名，引用传递相当于对这块地址做了修改，任何在函数内对该引用的改变都在返回后任然保留修改。所以更多的使用const是没有问题的。

被调函数的任何改变都会被处理为间接寻址；



#### 3.3 区别

虽然都是开辟在栈空间上的一个地址，但是对于引用参数的任何处理，都会处理为间接寻址，而对于指针参数而言，对指针作出修改是不会反映到实参的，但对指针指向的内容就会反馈到实参中；

引用在符号表中与实参名字不同，但地址相同，符号表形成后不允许修改，所以对于引用而言，不能修改指向的值；





### 4. const 和 static 关键字

#### 4.1 static

作用：控制变量的存储方式和可见性；

1. 修饰局部变量：本来存储在栈区，但是修饰过后，就会存储在静态变量区，静态变量区中的变量生命周期与程序相等，但是该局部变量的作用域并不会改变；

2. 修饰全局变量：对全局变量而言，本来是整个工程可见，变成了仅有一个文件可见；（修改了作用域）

3. 修饰函数：也是修改了作用域；

4. 修饰类：如果对类中的某个函数使用了该static修饰，就代表这个函数属于该类而不属于某个特定对象，也就是说仅存在一个副本，既可以通过类去调用，也可以通过对象去调用；

5. 修饰类成员/类函数：

   仅能在类的作用范围内使用，static成员函数只能访问static成员变量；

   static对象初始化必须在类外，因为static的初始化在类初始化之前，所以必须在外面初始化；	

   static不能被virtual修饰，因为虚函数需要this指针来调用，static函数不存在；



#### 4.2 const

const关键字；

1. 修饰指针和引用

   如果在*左边， 代表const 指针，也就是指针指向的内容不能改变，如果在 * 右边，修饰的就是p，也就是指针不能改变；

2. 修饰基本数据类型

   不能修改该数据；

3. const引用到函数中

   作为参数：变量初始化临时常量，在该函数中不可以更改这个常量的值，起到了保护作用，一般用来修饰指针形参和引用形参；

   声明了const返回值以后，const按相应的修饰原则保护返回值；

4. const在类中的用法

   成员变量：只能在构造函数的初始化列表中初始化，不能在类中初始化；

   成员函数：防止成员函数修改对象的内容，**不能与static连用**，因为static不能实例化，而const必须具体到某一个函数；

   修饰类对象，定义常量对象：常量对象只能调用常量成员函数，其他都不能调用；

5. const类成员函数

   常量对象只能调用类中的const成员函数，但不能调用非const成员变量；（调用成员函数时，在形参面前自动跟一个this指针，也就是this * const，该指针指向的地址不能改变，但如果在形参列表后加了const，就会导致const指针变成指向常量的常量指针，内容也不能修改了）

   非常量对象都能调用。





### 5. C和C++的区别

基本语句：几乎没有区别；

#### 01 新增的语法和关键字：

auto，explicit，new，delete；

允许定义自己的命名空间；

#### 02 重载函数和虚函数

C++中支持根据不同参数调用不同函数，原因是C++编译器会将参数添加到函数名后面，名字修饰不同；增加了虚函数的概念用以实现多态

#### 03 struct和C++中的类有很大不同

C++中的struct不仅可以有成员变量和成员函数，还有用了访问权限，其中C++struct中的访问权限默认是public；C++中还有class表示类

#### 04 C++中提供模板

模板来重用代码，还提供了更强大的STL标准库；



### 6. C++和java的区别

#### 01 指针

java程序员不能直接使用指针来访问内存，保证了程序的安全性；

#### 02 多重继承

java中没有多重继承，但是有接口；

#### 03 数据类型和变量

java是一个完全面向对象的语言，所有函数和变量必须是类的一部分

#### 04 自动内存管理

java自动进行无用内存的回收，所有对象都是用new创建在内存堆栈上的；

#### 05 操作符重载

java不支持操作符重载

#### 05 类型转换

java不支持隐式类型转换；





### 7. C++中常量的存储

如果是局部常量，直接存在栈区；

如果是全局常量，编译器一般不分配内存，直接存在符号表；

对于字面值常量，直接存在常量区；



### 8. 重载、重写、重定义

#### 01 重载

静态多态；

重载是函数名相同，参数不同（包括参数数量，类型，顺序），根据参数列表调用不同函数，重载并不关心函数的返回类型，可以一样，也可以不一样，但如果只有返回类型不一样，不是重载；

#### 02 重写

动态多态；

重写一般发生在子类重写父类的虚函数，除了函数体不同，其他一定完全相同；

被重写的函数不能是static，一定要是虚函数；重写和被重写的函数一般在不同的类中； 

#### 03 重定义

派生类中重定义父类中名字 相同的非virtual函数；

也就是覆盖了，只有virtual且其他完全相同才不会被重定义，也就是被父类覆盖；



### 9. 构造函数

#### 9.1 无参构造函数

默认构造函数，系统自动生成的，如果有自定义的构造函数，则需手动写出来；



#### 9.2 一般构造函数

有参数的构造函数，根据不同参数列表选择构造函数；



#### 9.3 拷贝构造函数

参数列表为自己的类型的引用的构造函数；在初始化 时会调用这个构造函数；

系统会自己创建一个默认的；



#### 9.4 等号运算符重载

运算符重载，在赋值时调用；这种情况必须是等号两边的对象都已经被创建，否则就会调用拷贝构造函数；



#### 9.5 类型转换构造函数

参数类型为一个其他类的构造函数，如果不想要有隐式转换，就需要将构造函数的设为explicit的；



### 10. 四种显式类型转换

static_cast ： 上行转换安全，下行转换不安全；

dynamic_cast ：专用于派生类之间的转换，下行转换安全，如果派生类之间使用了static_cast，可能导致错误的类型转换；

const_cast：专用于const属性的转换，可以去除const属性，也可以添加const属性

reinterpret_cast：十分危险的转换，从底层重新解释，可移植性非常差，可以在指针，引用，数组间随意转换，很危险；



### 11. 指针和引用的区别

指针是一个实体，引用是一个别名，在符号表上，指针有自己的地址，引用的没有自己的地址，指针可以为空，可以拷贝，可以更改指向，是一个实体，sizeof指针得到的是指针的大小；

作为参数传递的时候也不一样，指针参数本质是传值，而引用本质是传地址。



### 12. 野指针和空悬指针

野指针：没有初始化的指针，

悬空指针：是指针最初指向的内容已经被释放的指针

使用他们都是指向无效区域的不安全指针，会出现Undefined Behaviour错误；

避免使用野指针：智能指针和优先定义



### 13. const指针如何区分

const修饰类型，指针指向的内存不可更改；

const修饰指针， 指针的内容不可变，指针本身是常量；

const关键字后面跟的什么，就修饰什么；



### 14. 函数指针

定义：就是一个指向函数入口地址的指针，可以通过函数指针调用函数；

用途：调用函数和作为函数的参数；



### 15. 堆栈的区别

#### 01 栈

栈是由编译器自动分配空间并释放的一段较小的空间，第一条入栈的是main函数；

入栈顺序：

1. 函数的可执行地址；
2. 参数（参数入栈的顺序是从右往左）**？？？**；

**栈的空间是连续的**，并且由高地址向低地址扩展；



#### 02 堆

由程序员自主分配的，通过new，delete，malloc，free来分配；

有一段空闲链表来管理，当需要空间时，就查找该空闲链表；堆是低地址向高地址拓展，空间较大，较为灵活；



### 16. 函数传参的方式

1. 值传递： 形参是实参的拷贝，对该形参的操作不会影响实参；
2. 指针传递： 值传递的一种，形参指向实参的地址，对该形参的指向进行操作的时候，就是对实参进行操作，但更改指向不会影响指针；
3. 应用传递：实际上是把应用对象的地址放在了栈空间，函数内部对形参的任何操作都会影响到外部实参；



### 17. new&delete 和 malloc&free

#### 01 new&delete

- new ：new由两个步骤组成：
  1. malloc：根据类型分配合适的空间，如果在这一步出现异常，分配失败，返回一个bad_alloc异常；
  2. 在该空间上调用对象的构造函数初始化这片空间，如果这一步失败，就会自动调用delete；
- delete：
  1. 调用析构函数；
  2. free：释放空间；



#### 02 malloc&free

这两个函数只对空间进行操作，并不会初始化；

之所以C++重新定义了new和delete运算符，是因为free和malloc是库函数，编译器没有控制权限，不能将构造析构的操作强加于库函数，所以重新定义了两个运算符；



### 18. volatile和extern

#### 01 volatile

- 易变性：在汇编层面来说，并不从寄存器中读取该变量， 而是返回到内存中进行读取；
- 不可优化性：volatile告诉编译器该语句不允许优化，也就是说程序员写的语句一定会执行；
- 顺序性：编译器不会对volatile变量进行乱序优化；



#### 02 extern

用来修饰变量或函数，放在声明的前边，表示该函数或变量定义在别的地方，extern声明也受作用域的影响；

extern还可以加速编译速度；

也可以用来规范C++函数的调用规范，用来解决C程序和C++程序目标代码中命名规则的不同，以此来解决名字匹配的问题；



### 19. define和const区别

#### 01 define

在预编译阶段进行简单的字符串替换，运行时，宏定义并不会为宏定义分配内存；



#### 02 const

常量保存在常量区或者符号表，只进行一次内存的拷贝，从汇编的角度来讲，const常量出现的地方是真正数据的内存地址；而且还会进行类型检查；



### 20. sizeof的常见陷阱

1. 空类内存大小为1；
2. static不会计算在对象内存中；
3. 有虚函数就有虚指针，大小为4 或者 8（看操作系统）；



### 21. 面向对象的三大特征

#### 01 封装

客观的事物封装成类，并为数据和操作设置不同的保护级别，只让信任的类或对象进行操作；

防止无关的或错误的部分意外调用修改数据；



#### 02 继承

实现按级继承， 让子类能够使用父类的属性和操作；

一般分为实现继承和接口继承；

- 实现继承：子类是父类的一种实现，不需要任何操作，能直接使用基类的属性和操作；
- 接口继承：仅继承父类的属性和函数名，但必须保证子类要实现父类中的函数；



#### 03 多态

一个接口，可以实现多个方法；

多态与非多态的区别就是函数地址早绑定还是晚绑定；

早绑定就是在编译器就确定了函数运行的地址；

晚绑定就是在运行期才确定函数运行地址；



### 22. 多态的实现

重载属于静态多态，在同一个类中发生， 而常见的多态是指子类重写父类的虚函数，并在运行期才确定函数的地址；

动态多态的实现与虚函数表，虚函数指针相关；



### 23. 虚函数相关

#### 01 多态的体现

在父类中写virtual函数，然后在子类中重写这个函数，在运行期，根据对象的类型调用不同的函数，如果是基类调用基类的virtual函数，子类则调用子类的重写函数；

当一个类中含有虚函数时，生成一个虚函数表，子类如果继承了带有虚函数的基类，也会有虚函数和虚函数表， 检测到派生类有虚函数，也会为派生类生成一个虚函数指针，指向自己类型的虚函数表，虚函数指针的初始化是在构造函数中完成的；

如果有一个基类的指针指向了一个派生类，就会调用派生类的虚函数指针，调用派生类的虚函数表和虚函数；



### 24. 编译器处理虚函数表

- 首先拷贝基类的虚函数表，如果有多个基类，就拷贝多个表，
- 查看是否有重写的虚函数，如果有，就将虚函数中的表替换成派生类的虚函数，同时查看是否有自己的虚函数，有就加入到虚函数表中；



### 25. 作为基类的类析构函数写成虚函数

降低内存泄露的可能，如果一个基类指针指向派生类，如果此时析构函数不是虚函数，就会调用基类的析构函数，则派生类的派生部分无法正确释放，导致内存泄漏；



### 26. 构造函数为什么一般不设为虚函数

- 虚函数的调用只需要知道函数的接口，而构造函数需要知道确切的信息，尤其是确定的类型；
- 虚函数指针是在实例化之后被创建的，也就是在构造函数中被创建，虚函数的调用需要使用虚函数指针，两者是冲突的；



### 27. 构造函数或析构函数中调用虚函数

执行构造函数和析构函数时，一般是先执行基类的构造函数，此时调用派生类的虚函数，编译器无法识别这种未初始化的东西，就先当作不存在；

析构函数同理，调用析构函数时，自身的成员呈现一种未定义的状态；



### 28. 析构函数的作用

撤销对象的一些特殊处理，可以是释放空间；

析构函数没有参数，返回值，也不能重载；



### 29. 构造函数和析构函数的执行顺序

构造函数：

1. 基类构造函数，按照在类派生表中的顺序；
2. 成员类构造函数，按照类的声明顺序；
3. 派生类构造函数；

析构函数

1. 派生类析构；
2. 成员类析构；
3. 基类析构；



### 30. 纯虚函数

有纯虚函数的类就是抽象类，不能实例化，它的派生类必须继承接口的同时实现接口；



### 31. 动态绑定和静态绑定

动态绑定：在运行期确定类型（虚函数）；

静态绑定：在编译器就确定类型，包括缺省参数值也是静态绑定；

所以不应该重新定义缺省参数值；



### 32. 深拷贝和浅拷贝的区别

在出现=赋值的时候，会调用拷贝函数，系统默认的拷贝函数就是浅拷贝，能够完成成员的一一复制，在成员没有指针的时候，浅拷贝是可行的

当对象中有指针时，就会出现两个指针指向一个地址的问题，析构其中任意一个对象，会导致另一个对象的指针出现野指针的情况；

深拷贝的区别就是深拷贝会在堆内存中重新开辟区域存储数据，解决野指针的问题；

### 33. 拷贝构造函数的调用

三种情况：

- 对象以值传递的方式传入参数；
- 对象以值传递的方式从函数值返回；
- 一个对象需要从另一个对象进行初始化



### 34. 拷贝构造函数用引用传递的原因

如果采用值传递，就需要构造一个临时对象来进行值传递，形成无限递归；



### 35. 结构体内存对齐

对于结构体每个成员，第一个地址为0的话，其他成员偏移量必须是

min（#pragam pack（））的倍数；

内存对齐的好处：

1. 

1. 内存对齐有利于提高CPU的访问速率， 因为CPU是按照块的大小来访问的，如果偏移量不合适，就会让CPU做很多多余的工作；
2. 内存对齐有利于平台的移植，一些平台并不允许程序访问特定的地址；



### 36. 内存泄漏

定义：系统的一块内存被分配，但从未被释放，一直运行下去会导致内存越来越少；从而导致系统崩溃；



检测：

1. swap命令观察还剩多少内存，如果剩的越来越少，就是泄露了内存；
2. 使用netstat等应用
3. valgrind等检查性能和程序的工具



### 37. 平衡二叉树和高度平衡二叉树

高度平衡二叉树：左右子树高度最多相差1的二叉树；



### 38. 红黑树

定义：

1. 节点为黑红两色
2. 红色节点的子节点一定是黑色；
3. 任意节点到子节点的黑色节点数相等；
4. 每个叶子节点是黑色
5. 根节点是黑色



### 39. define，const，typedef，inline区别

#### 01 define与const定义

- define只是扩展字符串，在预编译阶段处理，const在编译阶段处理；
- define没有类型检查，而const有
- define占用代码段空间，而const占用数据段空间；
- define可以通过undef取消并重定义，const不能重定义
- define具有自己的独特功能：防止文件重复引用；



#### 02 #define与typedef

- define执行在预编译阶段，typedef在编译期，有类型检查；
- define不仅可以用来取类型别名，也可以定义常量变量等；
- define没有作用域，而typedef只能在作用域内有效；



#### 03 define与inline区别

- inline是关键字和#define都是关键字；
- inline具有类型检查，define没有
- 宏定义在预处理阶段替换，inline在编译期替换；



### 40 预处理，编译，汇编，链接程序

1. 预处理：将源程序（.c）中的所有头文件修改，将引用的头文件添加到程序文本中，预处理后以.i结尾；
2. 编译：将源程序编译成汇编语言程序，此时一般是.s结尾，不同的高级语言都会编译成相同的汇编语言；
3. 汇编：将汇编语言翻译成机器语言指令，并将这些指令打包成可重定位的目标程序，以.o结尾，是一个二进制的文件，字节码是机器语言指令而不再是字符；
4. 链接：将外部库中的函数的二进制文件链接并打包到一个可执行文件中，这个过程就是链接；



### 41 fork，wait，exec函数

fork让子进程拷贝一个父进程的副本，只拷贝了父进程的页表，两者读同一块内存；

当有进程写的时候，exec函数加载一个elf文件替代父进程，这样就可以运行不同的程序了；

fork从父进程返回子进程的pid，而从子进程返回0；调用wait，父进程会阻塞，知道子进程状态改变；

exec则子进程从新的程序开始运行；



### 42 动态编译与静态编译

静态编译：编译器在编译可执行文件时，将动态链接库中的部分提取出来，连接到可执行文件中，这样就不需要再依赖动态链接库；

动态编译：可执行文件需要附带一个动态链接库；

- 优点：缩小程序体积，加快编译速度；
- 缺点：对函数库有依赖性，可移植性较差；



## 二、数据和抽象

### 1. 类的继承

#### 01 类之间的关系

has-a：包含关系，一个类包含另一个类，通常是以属性的方式出现在另一个类中；

is-a：继承关系 ，一个类以public的方式继承另一个类，使用另一个类的属性和函数；

use-a：使用的方式，通常以友元或者参数的方式出现；



继承：一个类继承另一个类的属性和方法；



#### 02 继承的特点

子类可以拥有父类所有的属性和函数，子类可以拥有自己的属性和函数，子类对象可以当作一个父类对象来使用；



#### 03 继承的访问控制

public，protect，private；



### 2. 组合

一个类的对象是另一个类的成员；

构造函数的顺序，先调用成员类对象的构造函数，顺序是按照内嵌成员的顺序，与初始化列表无关，然后调用组合类的构造函数；

析构函数则刚好相反；



### 3. 构造函数析构函数能否抛出异常

C++只会析构一个完成的对象，如果构造没有完成，就不能调用析构函数，会导致内存泄漏的问题出现；

如果析构函数出现异常， 就会导致某些内存没有释放；



### 4. 实现只能动态分配和只能静态分配

#### 01 只静态

将new和delete重载为private；就只能静态分配了；



#### 02 只动态

将构造函数和析构函数设为protected，由子类来构造和析构；



静态：编译器分配内存在栈上；

动态：new寻找内存分配在堆上；



### 5. 成员初始化列表

初始化引用变量；

初始化const变量；

调用基类的构造函数，调用一个成员类的构造函数，他们都拥有一组参数的时候，编译器会一一操作初始化列表，以适当的顺序在构造函数之前执行初始化操作；由成员出现的顺序决定，而不是初始化列表中的排列顺序决定；

### 6. 析构函数被扩展的过程

析构函数函数体被执行；

如果class拥有成员类对象， 并且后者有析构函数，就会以相反的声明顺序被调用；

如果对象有vptr，现在就会被重新定义；

如果有任何上一层的非虚基类拥有的析构函数，他们会以被声明的顺序调用；



### 7. 构造函数的执行算法

先调用所有基类（包含虚基类）的构造函数；

对象的vptr被初始化；

有成员初始化列表就在构造函数体内展开来，这一步必须在vptr之后；

执行程序员的代码；



### 8. 构造函数的扩展过程

记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并于成员的声明顺序相同；

如果成员并没有出现在成员的初始化列表中，有一个默认构造函数，那么调用；

如果有虚表，必须设置初值；

所有上一层的基类构造函数必须调用；

虚基类的构造函数必须调用；



### 9. 哪些函数不能是虚函数

- 构造函数（有虚函数的类都有一个虚表，虚指针指向这个表，但是虚指针在构造函数中初始化）；
- 内联函数：内联函数意味着在编译器进行替换，而虚函数意味着在运行期才会确定状态，所有不能连用；
- 静态函数：静态函数不属于对象属于类，静态成员函数没有this指针，所以将静态成员函数设为虚函数没有意义；
- 友元函数，友元不能继承，没有意义设为虚函数；
- 普通函数：不属于成员，无法继承；



## 三、STL容器和算法

### 1. C++中STL

- 容器：vector，map，set，queue；
- 算法：sort，find；
- 配接器：通过容器实现功能的数据结构；
- 配置器：分配内存和空间；
- 迭代器：类指针，用于实现容器内的遍历等操作；
- 仿函数：重载了operator（）的类，帮助算法实现不同的策略；



#### 01 vector

动态空间，维护三个迭代器，指向开头的，指向已用空间的末尾，指向已分配空间的末尾，插入数据时先检测空间是否足够分配，不够就需要增加空间：

**增加空间：** 增加空间是通过重新分配一片更大的空间，然后释放原有空间，这也导致了vector迭代器的失效；



#### 02 list

list的好处是可以随意增删元素，每次增删只需要增删一个元素的空间，因为list是双向链表，所以list使用的迭代器是双向指针；



#### 03 deque

deque是一个双向开口的连续线性空间，没有容量的概念，内存空间不足可以直接在内存空间重新申请一段，然后通过迭代器造成空间连续的假象，这非常复杂，比vector要复杂的多；



#### 04 stack

先进后出，没有迭代器，只能对栈顶元素进行操作（push，pop，top）；



#### 05 queue

先进先出，没有迭代器；



#### 06 heap

堆，并没有这个数据结构，但是作为算法保实现了优先队列（priority_queue）；

逻辑实现是用一棵二叉树，保证二叉树的节点比子节点大，算法实现是：插入节点时，通过上溯程序不断比较，如果大就不断交换位置；而删除节点时，将根节点放到最右叶子节点， 取出最右叶子节点的值，然后不断下溯，直到根节点为止，底层实现是vector。



#### 07 priority_queue

pop操作一定推出该结构中的最大值；底层实现是vector



#### 08 slist

单向链表；



### 2. vector的注意事项以及频繁调用push_back（）的影响

#### 01 注意事项

- 插入和删除时需要注意迭代器失效的问题；
- 如果存的是指针需要逐项delete；



#### 02 push_back（）

如果超过了分配的空间，就会重新分配空间，并拷贝旧数据到新数据，这个过程非常耗时耗力；



### 3. map和set的区别

底层实现：红黑树；



#### 01 map和set的区别

- map是一个键值对，set的值不可修改；
- set的迭代器是const，map允许修改值，不允许修改key，原因是他们都是根据key来排序，修改key会导致严重的结构损坏；
- map支持下标操作，但是如果没有该键值对，就会创建；



### 4. STL删除元素

对于序列容器vector和deque来说，删除元素就会导致该元素后面的迭代器失效，所有后面的元素往前挪一位，然后返回下一个有效的迭代器；

对于map，set来说，使用erase后，并不会影响其他迭代器；

对于list，分配并不连写，上面两种方法都可以使用；



### 5. 迭代器的使用，有指针为何需要迭代器

封装指针，保护数据；

用于聚合对象的模式，即使不知道底层访问，也会能按照给定的顺序访问迭代元素；

**迭代器是类，不是指针**。这一点非常重要，以类来封装指针，可以减小内存泄漏的可能；

迭代器返回对象的引用；



### 6. resize和reserve的问题

resize：改变当前容器内含有的元素的数量，元素不足则添加元素；

reserve：改变当前容器的capacity，不会生成元素，如果 len >原来的capacity，就会重新分配空间然后拷贝；
