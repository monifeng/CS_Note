# 计算机八股文



## 一、 语言基础

### 1. 智能指针（4种）

头文件：<memory>。

> 智能指针的作用是方便程序员分配内存时忘记释放内存，造成内存泄漏的发生。

智能指针的原理是：本身是一个**类**，然后在析构的时候，会自动释放资源。函数结束时，自动释放内存空间。

#### 1.1 auto_ptr(已弃用)

采用所有权方式，已经被unique_ptr所取代，原因是有内存崩溃的可能。

p1指向一个指针，然后p2指向p1，p1指针所有权已被剥夺，但是此时编译器不会报错，运行时才会报错，也就是内存泄漏；



#### 1.2 unique_ptr（独占式）

本质上也是一种所有权方式，只能有一个unique_ptr指向一个内存。

当第二个指针指向相同内存时候会报错。

1.3 shared_ptr（强引用）

sp，会有一个计数器，允许多个指针指向同一个内存，释放时计数器-1，如果计数器归零，就会释放内存。

#### 1.4 weak_ptr（弱引用）

wp主要是辅助sp，并不会添加计数器，但是也不能改变指向的值，可以解决是sp相互引用的死锁问题（将其中一个sp改为wp）。

#### 1.5 代码示例

```c++
#include <memory>
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

int main() {
	unique_ptr<int> up1(new int(10));
	unique_ptr<int> up2;
	cout << *up1 << endl;
	// up2 = up1; // 会报错,无法这样赋值。

	shared_ptr<int> sp1(new int(20));
	shared_ptr<int> sp2;
	sp2 = sp1;
	cout << *sp2 << " " << *sp1 << endl;
	cout << "sp1计数器: " << sp1.use_count() << endl;
	
	weak_ptr<int> wp1 = sp1;
	cout << "weak_ptr不影响计数器（弱引用）" << *(wp1.lock()) << endl;
	cout << "sp1计数器: " << sp1.use_count() << endl;

	system("pause");
	return 0;
}
```

输出结果：

![image-20230102233320457](C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20230102233320457.png)





### 2. 内存空间

**堆：** 程序员分配的内存空间，使用 new， delete 等关键字来分配，但需要注意的是需要清理，并不能自动清理，否则会出现问题；

**栈：** 程序自己分配的内存空间，主要存储局部变量；

**全局/静态变量区：** 存储全局变量和静态变量；

**常量区：** 存储常量；

**代码区：** 存储二进制代码。



### 3. 指针传递和引用传递

#### 3.1 指针传递

本质上是一种值传递，传递得是一个地址，进入函数时，对这个地址做改变不会影响原有地址；但如果对地址指向的内存进行改变，则会影响该内存的东西；

```c++
void fun(int *a, int* b)
{
	swap(a, b);
//	int tmp = *a;
//	*a = *b;
//	*b = tmp;
}
```

例如本例中，swap **a** 和 **b** 的**地址**，但返回主函数以后，a 和 b 的地址并没有改变，因为相当于对fun内的临时变量做了改变，并不影响实参。

但如果把注释的内容取消，则会对 a 和 b **指向的内容** 作出改变。



#### 3.2 引用传递

引用本身就是那块地址的别名，引用传递相当于对这块地址做了修改，任何在函数内对该引用的改变都在返回后任然保留修改。所以更多的使用const是没有问题的。

被调函数的任何改变都会被处理为间接寻址；



#### 3.3 区别

虽然都是开辟在栈空间上的一个地址，但是对于引用参数的任何处理，都会处理为间接寻址，而对于指针参数而言，对指针作出修改是不会反映到实参的，但对指针指向的内容就会反馈到实参中；

引用在符号表中与实参名字不同，但地址相同，符号表形成后不允许修改，所以对于引用而言，不能修改指向的值；





### 4. const 和 static 关键字

#### 4.1 static

作用：控制变量的存储方式和可见性；

1. 修饰局部变量：本来存储在栈区，但是修饰过后，就会存储在静态变量区，静态变量区中的变量生命周期与程序相等，但是该局部变量的作用域并不会改变；

2. 修饰全局变量：对全局变量而言，本来是整个工程可见，变成了仅有一个文件可见；（修改了作用域）

3. 修饰函数：也是修改了作用域；

4. 修饰类：如果对类中的某个函数使用了该static修饰，就代表这个函数属于该类而不属于某个特定对象，也就是说仅存在一个副本，既可以通过类去调用，也可以通过对象去调用；

5. 修饰类成员/类函数：

   仅能在类的作用范围内使用，static成员函数只能访问static成员变量；

   static对象初始化必须在类外，因为static的初始化在类初始化之前，所以必须在外面初始化；	

   static不能被virtual修饰，因为虚函数需要this指针来调用，static函数不存在；



#### 4.2 const

const关键字；

1. 修饰指针和引用

   如果在*左边， 代表const 指针，也就是指针指向的内容不能改变，如果在 * 右边，修饰的就是p，也就是指针不能改变；

2. 修饰基本数据类型

   不能修改该数据；

3. const引用到函数中

   作为参数：变量初始化临时常量，在该函数中不可以更改这个常量的值，起到了保护作用，一般用来修饰指针形参和引用形参；

   声明了const返回值以后，const按相应的修饰原则保护返回值；

4. const在类中的用法

   成员变量：只能在构造函数的初始化列表中初始化，不能在类中初始化；

   成员函数：防止成员函数修改对象的内容，**不能与static连用**，因为static不能实例化，而const必须具体到某一个函数；

   修饰类对象，定义常量对象：常量对象只能调用常量成员函数，其他都不能调用；

5. const类成员函数

   常量对象只能调用类中的const成员函数，但不能调用非const成员变量；（调用成员函数时，在形参面前自动跟一个this指针，也就是this * const，该指针指向的地址不能改变，但如果在形参列表后加了const，就会导致const指针变成指向常量的常量指针，内容也不能修改了）

   非常量对象都能调用。





### 5. C和C++的区别

基本语句：几乎没有区别；

#### 01 新增的语法和关键字：

auto，explicit，new，delete；

允许定义自己的命名空间；

#### 02 重载函数和虚函数

C++中支持根据不同参数调用不同函数，原因是C++编译器会将参数添加到函数名后面，名字修饰不同；增加了虚函数的概念用以实现多态

#### 03 struct和C++中的类有很大不同

C++中的struct不仅可以有成员变量和成员函数，还有用了访问权限，其中C++struct中的访问权限默认是public；C++中还有class表示类

#### 04 C++中提供模板

模板来重用代码，还提供了更强大的STL标准库；



### 6. C++和java的区别

#### 01 指针

java程序员不能直接使用指针来访问内存，保证了程序的安全性；

#### 02 多重继承

java中没有多重继承，但是有接口；

#### 03 数据类型和变量

java是一个完全面向对象的语言，所有函数和变量必须是类的一部分

#### 04 自动内存管理

java自动进行无用内存的回收，所有对象都是用new创建在内存堆栈上的；

#### 05 操作符重载

java不支持操作符重载

#### 05 类型转换

java不支持隐式类型转换；





### 7. C++中常量的存储

如果是局部常量，直接存在栈区；

如果是全局常量，编译器一般不分配内存，直接存在符号表；

对于字面值常量，直接存在常量区；



### 8. 重载、重写、重定义

#### 01 重载

静态多态；

重载是在**同一个作用域**中函数名相同，参数不同（包括参数数量，类型，顺序），根据参数列表调用不同函数，重载并不关心函数的返回类型，可以一样，也可以不一样，但如果只有返回类型不一样，不是重载；

> 是指在同一个作用域中定义多个具有相同名称但参数列表不同的函数或运算符（函数名相同、参数个数或参数类型不同）

如下的例子就是重载：

```c++
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}
```



#### 02 重写（override）

动态多态；

重写一般发生在子类重写父类的虚函数，除了函数体不同，其他一定完全相同；

被重写的函数不能是static，一定要是虚函数；重写和被重写的函数一般在不同的类中； 

**子类具有基类相同的函数名称、参数列表和返回类型**

```C++
class Animal {
public:
    virtual void speak() {
        std::cout << "Animal is speaking." << std::endl;
    }
};

class Cat : public Animal {
public:
    virtual void speak() override {
        std::cout << "Cat is meowing." << std::endl;
    }
};
```



#### 03 重定义

派生类中重定义父类中名字 相同的非virtual函数；

也就是覆盖了，只有virtual且其他完全相同才不会被重定义，也就是被父类覆盖；

**发生在继承中的重载**

```C++
class A {
	virtual void f1() {}
	int f2() {}
	virtual f3(int a, int b) {}
};

class B : public A {
	// void f1();	默认继承 
	int f2(int a, int b) {}	// 覆盖（重定义），调用B的f2只会使用该函数 
	virtual int f3(int a, int b) override {}	// 重写（override） 
};
```



### 9. 构造函数

#### 9.1 无参构造函数

默认构造函数，系统自动生成的，如果有自定义的构造函数，则需手动写出来；



#### 9.2 一般构造函数

有参数的构造函数，根据不同参数列表选择构造函数；



#### 9.3 拷贝构造函数

参数列表为自己的类型的引用的构造函数；在初始化 时会调用这个构造函数；

系统会自己创建一个默认的；



#### 9.4 等号运算符重载

运算符重载，在赋值时调用；这种情况必须是等号两边的对象都已经被创建，否则就会调用拷贝构造函数；



#### 9.5 类型转换构造函数

参数类型为一个其他类的构造函数，如果不想要有隐式转换，就需要将构造函数的设为explicit的；



### 10. 四种显式类型转换

static_cast ： 上行转换安全，下行转换不安全；

dynamic_cast ：专用于派生类之间的转换，下行转换安全，如果派生类之间使用了static_cast，可能导致错误的类型转换；

const_cast：专用于const属性的转换，可以去除const属性，也可以添加const属性

reinterpret_cast：十分危险的转换，从底层重新解释，可移植性非常差，可以在指针，引用，数组间随意转换，很危险；



### 11. 指针和引用的区别

指针是一个实体，引用是一个别名，在符号表上，指针有自己的地址，引用的没有自己的地址，指针可以为空，可以拷贝，可以更改指向，是一个实体，sizeof指针得到的是指针的大小；

作为参数传递的时候也不一样，指针参数本质是传值，而引用本质是传地址。



### 12. 野指针和空悬指针

野指针：没有初始化的指针，

悬空指针：是指针最初指向的内容已经被释放的指针

使用他们都是指向无效区域的不安全指针，会出现Undefined Behaviour错误；

避免使用野指针：智能指针和优先定义



### 13. const指针如何区分

const修饰类型，指针指向的内存不可更改；

const修饰指针， 指针的内容不可变，指针本身是常量；

const关键字后面跟的什么，就修饰什么；



### 14. 函数指针

定义：就是一个指向函数入口地址的指针，可以通过函数指针调用函数；

用途：调用函数和作为函数的参数；



### 15. 堆栈的区别

#### 01 栈

栈是由编译器自动分配空间并释放的一段较小的空间，第一条入栈的是main函数；

入栈顺序：

1. 函数的可执行地址；
2. 参数（参数入栈的顺序是从右往左）**？？？**；

**栈的空间是连续的**，并且由高地址向低地址扩展；



#### 02 堆

由程序员自主分配的，通过new，delete，malloc，free来分配；

有一段空闲链表来管理，当需要空间时，就查找该空闲链表；堆是低地址向高地址拓展，空间较大，较为灵活；



### 16. 函数传参的方式

1. 值传递： 形参是实参的拷贝，对该形参的操作不会影响实参；
2. 指针传递： 值传递的一种，形参指向实参的地址，对该形参的指向进行操作的时候，就是对实参进行操作，但更改指向不会影响指针；
3. 应用传递：实际上是把应用对象的地址放在了栈空间，函数内部对形参的任何操作都会影响到外部实参；



### 17. new&delete 和 malloc&free

#### 01 new&delete

- new ：new由两个步骤组成：
  1. malloc：根据类型分配合适的空间，如果在这一步出现异常，分配失败，返回一个bad_alloc异常；
  2. 在该空间上调用对象的构造函数初始化这片空间，如果这一步失败，就会自动调用delete；
- delete：
  1. 调用析构函数；
  2. free：释放空间；



#### 02 malloc&free

这两个函数只对空间进行操作，并不会初始化；

之所以C++重新定义了new和delete运算符，是因为free和malloc是库函数，编译器没有控制权限，不能将构造析构的操作强加于库函数，所以重新定义了两个运算符；



### 18. volatile和extern

#### 01 volatile

- 易变性：在汇编层面来说，并不从寄存器中读取该变量， 而是返回到内存中进行读取；
- 不可优化性：volatile告诉编译器该语句不允许优化，也就是说程序员写的语句一定会执行；
- 顺序性：编译器不会对volatile变量进行乱序优化；



#### 02 extern

用来修饰变量或函数，放在声明的前边，表示该函数或变量定义在别的地方，extern声明也受作用域的影响；

extern还可以加速编译速度；

也可以用来规范C++函数的调用规范，用来解决C程序和C++程序目标代码中命名规则的不同，以此来解决名字匹配的问题；



### 19. define和const区别

#### 01 define

在预编译阶段进行简单的字符串替换，运行时，宏定义并不会为宏定义分配内存；



#### 02 const

常量保存在常量区或者符号表，只进行一次内存的拷贝，从汇编的角度来讲，const常量出现的地方是真正数据的内存地址；而且还会进行类型检查；



### 20. sizeof的常见陷阱

1. 空类内存大小为1；
2. static不会计算在对象内存中；
3. 有虚函数就有虚指针，大小为4 或者 8（看操作系统）；



### 21. 面向对象的三大特征

#### 01 封装

客观的事物封装成类，并为数据和操作设置不同的保护级别，只让信任的类或对象进行操作；

防止无关的或错误的部分意外调用修改数据；



#### 02 继承

实现按级继承， 让子类能够使用父类的属性和操作；

一般分为实现继承和接口继承；

- 实现继承：子类是父类的一种实现，不需要任何操作，能直接使用基类的属性和操作；
- 接口继承：仅继承父类的属性和函数名，但必须保证子类要实现父类中的函数；



#### 03 多态

一个接口，可以实现多个方法；

多态与非多态的区别就是函数地址早绑定还是晚绑定；

早绑定就是在编译器就确定了函数运行的地址；

晚绑定就是在运行期才确定函数运行地址；



### 22. 多态的实现

重载属于静态多态，在同一个类中发生， 而常见的多态是指子类重写父类的虚函数，并在运行期才确定函数的地址；

动态多态的实现与虚函数表，虚函数指针相关；



### 23. 虚函数相关

#### 01 多态的体现

在父类中写virtual函数，然后在子类中重写这个函数，在运行期，根据对象的类型调用不同的函数，如果是基类调用基类的virtual函数，子类则调用子类的重写函数；

当一个类中含有虚函数时，生成一个虚函数表，子类如果继承了带有虚函数的基类，也会有虚函数和虚函数表， 检测到派生类有虚函数，也会为派生类生成一个虚函数指针，指向自己类型的虚函数表，虚函数指针的初始化是在构造函数中完成的；

如果有一个基类的指针指向了一个派生类，就会调用派生类的虚函数指针，调用派生类的虚函数表和虚函数；



### 24. 编译器处理虚函数表

- 首先拷贝基类的虚函数表，如果有多个基类，就拷贝多个表，
- 查看是否有重写的虚函数，如果有，就将虚函数中的表替换成派生类的虚函数，同时查看是否有自己的虚函数，有就加入到虚函数表中；



### 25. 作为基类的类析构函数写成虚函数

降低内存泄露的可能，如果一个基类指针指向派生类，如果此时析构函数不是虚函数，就会调用基类的析构函数，则派生类的派生部分无法正确释放，导致内存泄漏；



### 26. 构造函数为什么一般不设为虚函数

- 虚函数的调用只需要知道函数的接口，而构造函数需要知道确切的信息，尤其是确定的类型；
- 虚函数指针是在实例化之后被创建的，也就是在构造函数中被创建，虚函数的调用需要使用虚函数指针，两者是冲突的；



### 27. 构造函数或析构函数中调用虚函数

执行构造函数和析构函数时，一般是先执行基类的构造函数，此时调用派生类的虚函数，编译器无法识别这种未初始化的东西，就先当作不存在；

析构函数同理，调用析构函数时，自身的成员呈现一种未定义的状态；



### 28. 析构函数的作用

撤销对象的一些特殊处理，可以是释放空间；

析构函数没有参数，返回值，也不能重载；



### 29. 构造函数和析构函数的执行顺序

构造函数：

1. 基类构造函数，按照在类派生表中的顺序；
2. 成员类构造函数，按照类的声明顺序；
3. 派生类构造函数；

析构函数

1. 派生类析构；
2. 成员类析构；
3. 基类析构；



### 30. 纯虚函数

有纯虚函数的类就是抽象类，不能实例化，它的派生类必须继承接口的同时实现接口；



### 31. 动态绑定和静态绑定

动态绑定：在运行期确定类型（虚函数）；

静态绑定：在编译器就确定类型，包括缺省参数值也是静态绑定；

所以不应该重新定义缺省参数值；



### 32. 深拷贝和浅拷贝的区别

在出现=赋值的时候，会调用拷贝函数，系统默认的拷贝函数就是浅拷贝，能够完成成员的一一复制，在成员没有指针的时候，浅拷贝是可行的

当对象中有指针时，就会出现两个指针指向一个地址的问题，析构其中任意一个对象，会导致另一个对象的指针出现野指针的情况；

深拷贝的区别就是深拷贝会在堆内存中重新开辟区域存储数据，解决野指针的问题；

### 33. 拷贝构造函数的调用

三种情况：

- 对象以值传递的方式传入参数；
- 对象以值传递的方式从函数值返回；
- 一个对象需要从另一个对象进行初始化



### 34. 拷贝构造函数用引用传递的原因

如果采用值传递，就需要构造一个临时对象来进行值传递，形成无限递归；



### 35. 结构体内存对齐

对于结构体每个成员，第一个地址为0的话，其他成员偏移量必须是

min（#pragam pack（））的倍数；

内存对齐的好处：

1. 

1. 内存对齐有利于提高CPU的访问速率， 因为CPU是按照块的大小来访问的，如果偏移量不合适，就会让CPU做很多多余的工作；
2. 内存对齐有利于平台的移植，一些平台并不允许程序访问特定的地址；



### 36. 内存泄漏

定义：系统的一块内存被分配，但从未被释放，一直运行下去会导致内存越来越少；从而导致系统崩溃；



检测：

1. swap命令观察还剩多少内存，如果剩的越来越少，就是泄露了内存；
2. 使用netstat等应用
3. valgrind等检查性能和程序的工具



### 37. 平衡二叉树和高度平衡二叉树

高度平衡二叉树：左右子树高度最多相差1的二叉树；



### 38. 红黑树

定义：

1. 节点为黑红两色
2. 红色节点的子节点一定是黑色；
3. 任意节点到子节点的黑色节点数相等；
4. 每个叶子节点是黑色
5. 根节点是黑色



### 39. define，const，typedef，inline区别

#### 01 define与const定义

- define只是扩展字符串，在预编译阶段处理，const在编译阶段处理；
- define没有类型检查，而const有
- define占用代码段空间，而const占用数据段空间；
- define可以通过undef取消并重定义，const不能重定义
- define具有自己的独特功能：防止文件重复引用；



#### 02 #define与typedef

- define执行在预编译阶段，typedef在编译期，有类型检查；
- define不仅可以用来取类型别名，也可以定义常量变量等；
- define没有作用域，而typedef只能在作用域内有效；



#### 03 define与inline区别

- inline是关键字和#define都是关键字；
- inline具有类型检查，define没有
- 宏定义在预处理阶段替换，inline在编译期替换；



### 40 预处理，编译，汇编，链接程序

1. 预处理：将源程序（.c）中的所有头文件修改，将引用的头文件添加到程序文本中，预处理后以.i结尾；
2. 编译：将源程序编译成汇编语言程序，此时一般是.s结尾，不同的高级语言都会编译成相同的汇编语言；
3. 汇编：将汇编语言翻译成机器语言指令，并将这些指令打包成可重定位的目标程序，以.o结尾，是一个二进制的文件，字节码是机器语言指令而不再是字符；
4. 链接：将外部库中的函数的二进制文件链接并打包到一个可执行文件中，这个过程就是链接；



### 41 fork，wait，exec函数

fork让子进程拷贝一个父进程的副本，只拷贝了父进程的页表，两者读同一块内存；

当有进程写的时候，exec函数加载一个elf文件替代父进程，这样就可以运行不同的程序了；

fork从父进程返回子进程的pid，而从子进程返回0；调用wait，父进程会阻塞，知道子进程状态改变；

exec则子进程从新的程序开始运行；



### 42 动态编译与静态编译

静态编译：编译器在编译可执行文件时，将动态链接库中的部分提取出来，连接到可执行文件中，这样就不需要再依赖动态链接库；

动态编译：可执行文件需要附带一个动态链接库；

- 优点：缩小程序体积，加快编译速度；
- 缺点：对函数库有依赖性，可移植性较差；



## 二、数据和抽象

### 1. 类的继承

#### 01 类之间的关系

has-a：包含关系，一个类包含另一个类，通常是以属性的方式出现在另一个类中；

is-a：继承关系 ，一个类以public的方式继承另一个类，使用另一个类的属性和函数；

use-a：使用的方式，通常以友元或者参数的方式出现；



继承：一个类继承另一个类的属性和方法；



#### 02 继承的特点

子类可以拥有父类所有的属性和函数，子类可以拥有自己的属性和函数，子类对象可以当作一个父类对象来使用；



#### 03 继承的访问控制

public，protect，private；



### 2. 组合

一个类的对象是另一个类的成员；

构造函数的顺序，先调用成员类对象的构造函数，顺序是按照内嵌成员的顺序，与初始化列表无关，然后调用组合类的构造函数；

析构函数则刚好相反；



### 3. 构造函数析构函数能否抛出异常

C++只会析构一个完成的对象，如果构造没有完成，就不能调用析构函数，会导致内存泄漏的问题出现；

如果析构函数出现异常， 就会导致某些内存没有释放；



### 4. 实现只能动态分配和只能静态分配

#### 01 只静态

将new和delete重载为private；就只能静态分配了；



#### 02 只动态

将构造函数和析构函数设为protected，由子类来构造和析构；



静态：编译器分配内存在栈上；

动态：new寻找内存分配在堆上；



### 5. 成员初始化列表

初始化引用变量；

初始化const变量；

调用基类的构造函数，调用一个成员类的构造函数，他们都拥有一组参数的时候，编译器会一一操作初始化列表，以适当的顺序在构造函数之前执行初始化操作；由成员出现的顺序决定，而不是初始化列表中的排列顺序决定；

### 6. 析构函数被扩展的过程

析构函数函数体被执行；

如果class拥有成员类对象， 并且后者有析构函数，就会以相反的声明顺序被调用；

如果对象有vptr，现在就会被重新定义；

如果有任何上一层的非虚基类拥有的析构函数，他们会以被声明的顺序调用；



### 7. 构造函数的执行算法

先调用所有基类（包含虚基类）的构造函数；

对象的vptr被初始化；

有成员初始化列表就在构造函数体内展开来，这一步必须在vptr之后；

执行程序员的代码；



### 8. 构造函数的扩展过程

记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并于成员的声明顺序相同；

如果成员并没有出现在成员的初始化列表中，有一个默认构造函数，那么调用；

如果有虚表，必须设置初值；

所有上一层的基类构造函数必须调用；

虚基类的构造函数必须调用；



### 9. 哪些函数不能是虚函数

- 构造函数（有虚函数的类都有一个虚表，虚指针指向这个表，但是虚指针在构造函数中初始化）；
- 内联函数：内联函数意味着在编译器进行替换，而虚函数意味着在运行期才会确定状态，所有不能连用；
- 静态函数：静态函数不属于对象属于类，静态成员函数没有this指针，所以将静态成员函数设为虚函数没有意义；
- 友元函数，友元不能继承，没有意义设为虚函数；
- 普通函数：不属于成员，无法继承；



## 三、STL容器和算法

### 1. C++中STL

- 容器：vector，map，set，queue；
- 算法：sort，find；
- 配接器：通过容器实现功能的数据结构；
- 配置器：分配内存和空间；
- 迭代器：类指针，用于实现容器内的遍历等操作；
- 仿函数：重载了operator（）的类，帮助算法实现不同的策略；



#### 01 vector

动态空间，维护三个迭代器，指向开头的，指向已用空间的末尾，指向已分配空间的末尾，插入数据时先检测空间是否足够分配，不够就需要增加空间：

**增加空间：** 增加空间是通过重新分配一片更大的空间，然后释放原有空间，这也导致了vector迭代器的失效；



#### 02 list

list的好处是可以随意增删元素，每次增删只需要增删一个元素的空间，因为list是双向链表，所以list使用的迭代器是双向指针；



#### 03 deque

deque是一个双向开口的连续线性空间，没有容量的概念，内存空间不足可以直接在内存空间重新申请一段，然后通过迭代器造成空间连续的假象，这非常复杂，比vector要复杂的多；



#### 04 stack

先进后出，没有迭代器，只能对栈顶元素进行操作（push，pop，top）；



#### 05 queue

先进先出，没有迭代器；



#### 06 heap

堆，并没有这个数据结构，但是作为算法保实现了优先队列（priority_queue）；

逻辑实现是用一棵二叉树，保证二叉树的节点比子节点大，算法实现是：插入节点时，通过上溯程序不断比较，如果大就不断交换位置；而删除节点时，将根节点放到最右叶子节点， 取出最右叶子节点的值，然后不断下溯，直到根节点为止，底层实现是vector。



#### 07 priority_queue

pop操作一定推出该结构中的最大值；底层实现是vector



#### 08 slist

单向链表；



### 2. vector的注意事项以及频繁调用push_back（）的影响

#### 01 注意事项

- 插入和删除时需要注意迭代器失效的问题；
- 如果存的是指针需要逐项delete；



#### 02 push_back（）

如果超过了分配的空间，就会重新分配空间，并拷贝旧数据到新数据，这个过程非常耗时耗力；



### 3. map和set的区别

底层实现：红黑树；



#### 01 map和set的区别

- map是一个键值对，set的值不可修改；
- set的迭代器是const，map允许修改值，不允许修改key，原因是他们都是根据key来排序，修改key会导致严重的结构损坏；
- map支持下标操作，但是如果没有该键值对，就会创建；



### 4. STL删除元素

对于序列容器vector和deque来说，删除元素就会导致该元素后面的迭代器失效，所有后面的元素往前挪一位，然后返回下一个有效的迭代器；

对于map，set来说，使用erase后，并不会影响其他迭代器；

对于list，分配并不连写，上面两种方法都可以使用；



### 5. 迭代器的使用，有指针为何需要迭代器

封装指针，保护数据；

用于聚合对象的模式，即使不知道底层访问，也会能按照给定的顺序访问迭代元素；

**迭代器是类，不是指针**。这一点非常重要，以类来封装指针，可以减小内存泄漏的可能；

迭代器返回对象的引用；



### 6. resize和reserve的问题

resize：改变当前容器内含有的元素的数量，元素不足则添加元素；

reserve：改变当前容器的capacity，不会生成元素，如果 len >原来的capacity，就会重新分配空间然后拷贝；



## 四、C++11新特性

### 1. nullptr

为了替代NULL，因为NULL有时会被编译器直接视为0，如果我们重载一个形参为char* 的函数，形参改为int，那么当调用该参数并且实参填写为NULL的时候，会调用重载的函数，与直觉不符，所以鼓励使用nullptr。



### 2. lambda表达式

提供了一个匿名函数的特性；

产生的对象是函数对象，lambda可以自动推断返回类型。

简单用法如下：

```C++
// lambda
	auto printHello = [] { cout << "hello!" << endl; }
	pinttHello(); 	// 调用lambda

	auto add = [] (int a, int b) { return a + b; }
	int sum = add(3 + 4); // 7
```

原理：

前面的 `[]` 生成了一个闭包类；**闭包类型**就是重载了 `()` 运算符的匿名类，lambda表达式会自动返回一个匿名闭包实例（右值），可以让我们以传值或传引用的方式捕捉其作用域内的变量。

```c++
// 闭包类型的捕捉参数
	int x = 10;
	auto add_x = [x] (int a) { return a + b; }
	int a_add_x = add_x(10); 	// 20
```



应用：用于函数的参数，实现回调函数，常常与STL一起使用。

```C++
// lambda实际应用
	int val = 3;
	vector<int> v{1,2,3,4,5};
	
	int count = v.count_if(v.begin(), v.end(), [val] (int x) { return x > val; }) // 大于3的个数
```



### 3. 右值引用

允许我们对右值进行修改，直接从右值中拿数据来修改初始化左值。



### 4. 泛化常量表达式

`constexpr`  告诉编译器这是一个编译期常量。

```C++
	constexpr int N = 5;
	int a[N]; 	// ok
```



### 5. 初始化列表

```C++
class A{
public:
 A(std::initializer_list<int> list);
};
A a = {1, 2, 3};
```



### 6. 统一的初始化语法

`X x{...}` 就是较为统一的初始化语法。



### 7. 类型推导

主要有 `auto` 和 `decltype` ，可以自动推导类型。

```C++
for(vector<int>::const_iterator it = v.begin(); it != v.end(); ++it);
// 可以改写为
for(auto it = v.begin(); it != v.end(); ++it);
```

仅仅是简写，依然是强类型的语言，始终会进行静态的类型检查。



decltype会对表达式进行类型的推导，而不运行表达式。



#### 8. 范围for循环

```c++
vector<int> v(5, 1);

for(auto i : v)
{
	cout << i << endl;
}
```



### 9. 构造函数委托

可以在构造函数中调用其他的构造函数（包括自己的）



### 10. final和override

C++虚函数脆弱的地方：

- 无法禁止子类重写它；
- 容易隐藏父类的函数；

提供两个关键字来显式地解决该问题：

- final可以在编译时禁止重写声明的函数；
- override可以显式声明重写的函数，只有在父类和子类函数名和参数完全相同的时候才会成功重写

```C++
struct Base1 final { }; 
struct Derived1 : Base1 {}; // 编译错：Base1不允许被继承

struct Base2 {
     virtual void f1() final;
     virtual void f2();
};
struct Derived2 : Base2 {
     virtual void f1(); // 编译错：f1不允许᯿写
     virtual void f2(int) override; // 编译错：⽗类中没有 void f2(int)
};
```



### 11. default和delete

default方便在定义有参构造函数后直接生成一个默认的构造函数，而delete则是让编译器不自动生成函数（比如拷贝构造函数，就是禁止拷贝，或者赋值运算符，就禁止用=号）

```C++
struct classA {
     classA() = default; // 声明⼀个⾃动⽣成的函数
     classA(T value);
     void *operator new(size_t) = delete; // 禁⽌⽣成new运算符
};
```



### 12. static_assert

assert宏发生在运行期，而#error运行在预处理期，但他们都无法处理模板中的情况，因为模板的类型定义发生在编译期，所以静态assert就出现了。

```C++
template< class T >
struct Check {
 	static_assert( sizeof(int) <= sizeof(T), "T is not big enough!" ) ;
} ;
```



### 13. 智能指针

简单举例说明

```C++
int main(){
    std::shared_ptr<double> p_first(new double);
    {
         std::shared_ptr<double> p_copy = p_first;
         *p_copy = 21.2;
    } // p_copy 被销毁，⾥⾯的 double 还有⼀个引⽤因此仍然保持
     return 0; // p_first 及其⾥⾯的 double 销毁
}
```



### 14. 正则



### 15. 增强的元组



### 16. 哈希表

C++ 的 map , multimap , set , multiset 使⽤红⿊树实现， 插⼊和查询都是 O(lgn) 的复杂度， 但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1) 的复杂度：

![image-20230601151416887](https://gitee.com/moni_world/pic_bed/raw/master/img/image-20230601151416887.png)



## 五、数据结构和算法

### 1. 十大排序算法及其时空复杂度

![image-20230601151639235](https://gitee.com/moni_world/pic_bed/raw/master/img/image-20230601151639235.png)

算法的稳定性：相同键不会改变原有顺序。

#### 01 冒泡排序

```C++
void BubbleSort(std::vector<int> &nums, int n) {
     if (n <= 1) return;
     bool is_swap;
     for (int i = 1; i < n; ++i) {
         is_swap = false;
         //设定⼀个标记，若为false，则表示此次循环没有进⾏交换，也就是待排序列已经有序，排序已经完成。
         for (int j = 1; j < n - i + 1; ++j) {
             if (nums[j] < nums[j-1]) {
                 std::swap(nums[j], nums[j-1]);
                 is_swap = true;//表示有数据交换
             }
         }
         if (!is_swap) break;//没有数据交集，提前退出
     }
}
```



#### 02 插入排序

```c++
void InsertSort(std::vector<int> &nums,int n) {
 if (n <= 1) return;
 for(int i = 0; i < n; ++i) {
     for (int j = i; j > 0 && nums[j] < nums [j-1]; --j) {
         std::swap(nums[j],nums[j-1]);
     }
 }
}
```



#### 03 选择排序

每次找到未排序区间的最小元素，插入到已排序的最后，并不稳定。

不稳定的原因是从后往前找最小，相同键可能导致错序。

```C++
void SelectSort(std::vector<int> &nums, int n) {
     if (n <= 1) return;
     int mid;
     for (int i = 0; i < n - 1; ++i) {
         mid = i;
         for (int j = i + 1; j < n; ++j) {
             if (nums[j] < nums[mid]) {
             mid = j;
         }
     }
     std::swap(nums[mid],nums[i]);
     }
}
```



#### 04 快排

不稳定

```C++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;	// 递归出口

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```



#### 05 归并排序

稳定，但需要额外数组。

```c++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```





## 六、 计算机网络

### 1. osi七层模型

物理层， 链路层，网络层，传输层，会话层，表示层，应用层。



### 2. 各层功能

#### 01 物理层

保证原始数据可以在各个媒介上进行转换，传输bit流。

#### 02 数据链路层

在不可靠的数据链路上提供可靠的物理传输，作用包括：

物理地址寻址，封装成帧，流量控制， 数据的检错，重发，将bit流封装成frame帧。

#### 03 网络层

对子网间的数据包进行路由选择，网络层可以实现拥塞控制，网际互连功能，发送的是数据包。

#### 04 传输层

传输层是第一个端到端的层次，传输层负责将上层数据分段并提供端到端的，可靠或不可靠的传输，还要处理差错控制和流量控制，这一层的数据成为数据段。

#### 05 会话层

负责建立，管理，中止进程间的会话。

#### 06 表示层

解决用的语法表示问题，将数据转化为系统的传送语法，例如数据解压与压缩，主要是图像视频解码和编码，数据的加密等。

#### 07 应用层

位操作系统或网络提供接口（例如socket）。



### 3. 各层协议和传输单元以及性能设备

![image-20230606161142969](https://gitee.com/moni_world/pic_bed/raw/master/img/image-20230606161142969.png)

重点在网络层，传输层，应用层。



### 4. TCP协议的头部

- 源端口号（16bit）；
- 目的端口号（16bit）；

- 序号（32bit）：传输方向上的字节流的编号，ISN+偏移值，用于解决包的乱序问题；
- 确认号（32bit）：接收方对发送方的TCP报文段的响应，为收到的序号+1；
- 首部长（4bit）：标识首部有多少个4字节*首部长，最大为15，即60字节；
- 标志位（6bit）：
  - ACK：标识确认号是否有效（确认报文段），用于解决丢包问题。
  - RST： 请求对方重新连接（复位报文段）
  - SYN：表示请求一个连接（请求报文段）
  - FIN：表示关闭连接（断开报文段）
- 窗口（16bit）：接收窗口，用于告知对方己方还能接收多少数据，用于解决流量控制；
- 校验和（16bit）：用CRC检验整个报文段有无损坏；



### 5. TCP三次握手四次挥手

#### 01 三次握手

1. 客户发送含SYN位的数据包到服务端，并且序列号初始化为S（随机值）；（客 -> SYN_SEND）
2. 服务端发送含SYN位，ACK位的数据包到客户段，确认号为：S+1，序列号为P（随机值）；（服 -> SYN_RECV）
3. 客户发送含ACK位，并且ACK_NUM = P+1；（客 -> ESTABLISH，服 -> ESTABLISH）



在第二步服务端接收到SYN请求时，服务器分配资源，第三步时客户端分配资源。

**第三条报文可以携带数据，例如HTTP协议**



#### 第三次握手的原因

**第三次握手实际上就是客户端在告诉服务器，自己已经收到了它的初始序号，完成了同步，可以开始相互传输数据了，**若没有第三次握手，服务器将无法保证客户端接收到了自己的`SYNACK`报文段，若此时`SYNACK`报文段丢失，客户端不知道服务器的初始序号，将无法处理之后到达客户端的数据。



#### 02 四次挥手

1. 客户端发送含FIN位，并且序列号为Q的包到服务器；（客 -> FIN_WAIT_1）
2. 服务器发送含ACK位的包，应答号为Q+1的包到客户端；（服 -> CLOSE_WAIT，客 -> FIN_WAIT_2）
   - 此处等待
3. 服务器发送含FIN位的包，序列号为R到客户端；（服 -> LAST_ACK，客 -> TIME_WAIT）
   - 此处等待
4. 客户端发送含ACK位的包，应答号为R+1到服务端；（服 -> CLOSED）



#### 四次挥手的原因

TCP连接是双工的，TCP连接的双方都需要FIN和ACK来确认连接已经断开，所以需要四次。



#### 03 TCP连接的状态

CLOSED：初始状态；

LISTEN：服务器处于监听状态；

SYN_SEND：客户端执行CONNECT连接，发送SYN包，进入此状态；

SYN_RCVD：服务端接收到乐SYN包，发送SYN和ACK包，进入此状态；

ESTABLISH：客户端在发出ACK包后会进入此状态，服务端在收到ACK包后进入，表示连接已建立；

FIN_WAIT_1：中止连接的一方会在发出FIN包后进入此状态，等待对方的FIN（通常是客户机）；

CLOSE_WAIT：（通常是服务端）在收到FIN包后进入此状态，发一个ACK包回去，然后进入此状态，但本方什么时候发送发送FIN包，取决于数据是否发送完毕，在发送完毕之前都会在此状态；

FIN_WAIT_2：收到了自己发送的FIN的ACK包，此时是半连接状态，即有一方要求关闭连接，等待另一方关闭；通常是客户端收到了ACK包，但并没有接收到服务端的FIN包，此时进入WAIT2状态；

LAST_ACK：服务端发送了最后的FIN包，并等待ACK包；

TIME_WAIT：客户端在收到FIN包后，发送ACK包并在之后的2MSL都会在此状态；



#### 04 FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态

- FIN_WAIT_2

  - 收到来自服务端的ACK包，但是还没收到来自服务端的FIN包，就处于这个状态；
  - 处于关闭状态，仅能接收数据，不再具备发送数据的状态

- CLOSE_WAIT

  - 被动关闭连接的一方接收到ACK包并立刻发送ACK包；
  - 被动关闭连接的一方如果还有数据需要发送就会进入CLOSE_WAIT状态；

- TIME_WAIT状态

  - 发出最后的ACK包以后会进入此状态，等待2MSL后进入CLOSED状态；
  - 防止最后一次ACK包丢失无法重传而设计的TIME_WAIT状态；
  - 在2MSL时间内，旧的socket不能在使用，防止新旧数据混淆；


#### 05 RTT和RTO和超时重传

- RTT

  就是从发送到接收到对方响应的时间，即数据报在网络中往返的时间，并不固定；

- RTO

  重传间隔，从上一次发送数据，因为长期没有收到ACK报文的回应，所间隔的时间；

  每次重传是前一次重传间隔的两倍，通常是1RTT，2RTT……，直到达到重传次数上限；

- 发送窗和接收窗

  - 发送窗：就是限制发送方可以发送的数据的大小，用来告知接收端自己的缓冲大小（受硬件，系统限制），发送窗口的大小由TCP报文的返回来控制；
  - 接收窗：用来标记可以接收的数据大小；
  - 发送窗的数据只有收到ACK回应才会移动，左边缘紧贴刚刚确认的数据；
  - 接收窗只有接收到数据并且数据最左端连续才会继续；

- 拥塞控制的原理

  - 拥塞控制就是为了防止网络中数据注入过多，造成网络链路过载，因为拥塞控制涉及到网络链路全局，属于全局控制；拥塞控制使用拥塞窗口；

  - TCP拥塞控制算法

    - 慢开始 & 拥塞避免：

      首先按指数增大发送的字节数，到达阈值（ssthresh）后，按线性增长（拥塞），只要发送方判断出现拥塞（即发送方收到回应超时）就把门限值设为发生拥塞的一般，重新进行慢开始 & 拥塞避免。

    - 快速重传 & 快速恢复：

    - 最终拥塞窗口会趋于稳定值；



#### 06 区分流量控制和拥塞控制

- 流量控制属于点对点的，仅仅只对通信双方有用，拥塞控制属于全局的控制，可以控制全局；
- 流量控制的实现基于双方的发送窗口和接收窗口，接收窗空由自己确认，发送窗口由对方的回复报文来确认。
- 拥塞控制的窗口由发送数据试探决定；



### 6.  TCP的可靠传输的实现

- 建立连接（标志位）：确认通信实体存在；
- 序列号和确认好：保证数据有顺序；
- 数据校验和（CRC）：校验全部数据是否损坏丢失；
- 超时重传：保证因链路故障导致未到达数据能够到达；
- 窗口机制：提供流量控制，避免过量发送；
- 拥塞控制：同上；



### 7. TCP socket交互流程

- 服务端

  - 创建socket， int socket(int domain, int type, int protocol);

  - 绑定socket和端口号， int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

    ```c++
    // IPv4的sockaddr地址结构
     struct sockaddr_in {
     sa_family_t sin_family; // 协议类型，AF_INET
     in_port_t sin_port; // 端⼝号
     struct in_addr sin_addr; // IP地址
     };
     struct in_addr {
     uint32_t s_addr;
     }
    ```

  - 监听端口号，int listen(int sockfd, int backlog)；

  - 接收用户请求，int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)；

    accept成功后会返回一个sockfd来标识唯一的连接；

  - 从socket中读取字符，ssize_t read(int fd, void *buf, size_t count)；

  - 关闭socket，int close(int fd)；

- 客户端
  - 创建socket；
  - 连接指定计算机， int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);
  - 向socket中写入消息， ssize_t write(int fd, const void *buf, size_t count);
  - 关闭socket；



## 七、操作系统

###  1. 操作系统的特性

并发，虚拟，共享，不确定性；



### 2. 什么是进程

1. 进程是操作系统中正在运行一个程序，程序一旦运行就是进程；
2. 进程是资源分配的最小单位，每个进程有自己独立的地址空间；
3. 进程间无法直接通信，需要通过进程间通信来实现：例如管道，消息队列等；
4. 线程是进程的一个实体，是运行的基本单位，一个程序至少有一个进程，一个进程至少有一个线程；



### 3. 进程

进程是程序的一次执行，可以并发执行；

进程由阻塞，运行，就绪三个基本状态；

进程调度算法：先来先服务，短作业优先，非抢占式优先级调度，抢占式优先级调度，高响应比优先级调度，时间片轮转调度算法；



### 4. 进程与线程的区别

1. 进程有自己独立的地址空间和资源，同一进程线程间的地址空间和资源是共享的；
2. 进程崩溃不会影响别的进程，线程一个崩溃则进程崩溃，多进程比多线程更健壮；
3. 进程切换会消耗更多资源，对于频繁切换上下文的程序，线程更好；
4. 均可并发执行；
5. 线程无法独立运行，必须依赖于应用程序；进程有自己的程序入口和出口；



### 5. 进程状态转换

![image-20230627165545484](https://gitee.com/moni_world/pic_bed/raw/master/img/image-20230627165545484.png)





### 6. 进程和线程的创建

1. 进程fork创建，子进程是父进程的完整副本，复制了父进程的资源，vfork创建，则共享数据段，并且子进程先于父进程执行；
2. 创建线程通常是pthread；



### 7. fork详解

1. pid_t fork(void); //void代表没有任何形式参数；

2. 除了0号进程系统创建，其他都由进程创建；

3. 返回值，子进程返回0，父进程返回大于0的数，出错返回1；

   ```c++
   int pid=fork();
   if(pid < 0){
   //失败，⼀般是该⽤户的进程数达到限制或者内存被⽤光了 
   ........ 
   }
   else if(pid == 0){
   //⼦进程执⾏的代码
   ......
   }
   else{
   //⽗进程执⾏的代码
   .........
   }
   ```



### 8. 父子进程的通信

1. fork（）和pipe（）；
2. 管道，连接读进程和写进程的，实现他们通信的共享文件；
3. 写进程在尾端写，读进程在管道手段读数据；



### 9. 死锁，必要条件，如何解决

#### 01 死锁的概念

多个进程循环等待它方占有的资源而导致的无限期等待的僵持局面；如果没有外力作用，将永远处于死锁状态。

#### 02 死锁的必要条件

1. 资源互斥条件
2. 不可剥夺条件
3. 循环等待条件
4. 请求和保持条件



#### 03 死锁的预防

1. 打破互斥条件

   允许资源同时被多个进程访问，实现简单，但意义不大，因为有些资源只能独占；

2. 打破不可剥夺条件

   允许强制占有互斥资源；

3. 破坏请求和保持条件

   如果不能占有全部资源，直接释放；

4. 破坏循环等待条件

   按顺序来获取资源（一般通过锁来实现）；

5. 鸵鸟策略

   如果解除或防止死锁的代价远大于死锁带来的麻烦，或者死锁发生的概率很低，可以置之不理。

#### 04 死锁避免：银行家算法

通过四个数组：

Available【】【】；

Allocated【】【】，

Max【】【】；

Needed【】【】；

> 关系：**Need[i,j] = Max[i,j] - allocation[i, j]**



1. request[i] <= Need[i]，跳入第二步，否则判断为出错；

2. request[i] <= Available[i]，跳入第三步，否则阻塞；

3. 尝试进行资源分配

   > Available[j] = Available[j] – Requesti[j]
   > Allocation[i,j] = Allocation[i,j] + Requesti[j]
   > Need[i,j] = Need[i,j] – Requesti[j]

4. 全部分配后，执行安全性检查算法，如果全部都过了，就可以







