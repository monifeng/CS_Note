# mysql学习



## 1.  mysql的执行过程

分成两个部分，先是客户端过程，在输入语句后：

### 1.1 连接器

连接数据库，并获取权限；

### 1.2 分析器

分析器会分析词法语法句法，然后判断通过后，进行下一个阶段；

*这个阶段会检查表的数据名称，但并未读取表！*

### 1.3 优化器

优化执行步骤；

### 1.4 执行器

执行语句，逐句执行，然后返回满足条件的结果集（也就是在这个阶段才开始读取表中数据）。

### 1.5 存储引擎

存储数据并提供读写接口。

![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)





## 2. 两种日志系统

### 2.1 bin log

bin log是mysql自带的日志系统，分为statment状态和row状态，前者记录**sql语句**， 后者记录 **行状态**（记两行，更新前后）。

bin log 主要是记录逻辑操作。

bin log 空间可以追加。



### 2.2 redo log

redo log是一种记录**物理状态**的，仅存在于innoDB的一种日志系统，主要记录的是

**”该页做了什么改动“**。

redo log 是一块**固定的空间**，无法更改空间大小，所以采用循环写的方式，当write point 追上 check point 时，就会将所有内容写入到引擎，然后才能继续写日志。



### 2.3 两阶段提交

在一条更新语句执行时，仍旧需要执行前面的连接器到执行器之间的操作，但是有一点不同的，需要先写日志，再更新引擎上的数据。步骤如下：

1. 写redo log， 记录做了什么改动，并进入prepare状态；
2. 写bin log， 记录做了什么操作，然后进入下一阶段；
3. redo log 进入commit 状态，然后更新引擎。

这样做的好处是：**crash Safe**， 也就是在发生意外时，我们可以直接通过日志，回滚到意外发生前的状态。

例如对下面的句子来说：

```sql
mysql> update T set c=c+1 where ID=2;
```

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)



### 2.4 恢复数据库

步骤如下：

1. 

1. 找到上一次的全量备份（redo log），然后恢复到上一次；
2. 找到那段时间到错误操作之前的所有操作（bin log），然后重新执行；
3. 最后就恢复到了错误操作之前的全量数据库。



## 3. 事务



### 3.1 事务的概念

事务的概念就是完成一系列连贯的操作，从begin或start transaction开始 



### 3.2 事务的特征(ACID)

- 原子性(Atomicity) : 指的是所有sql语句一次执行，全部成功，任意失败会导致回滚；
- 一致性(Consistency) ：指的是事务执行前后数据库正常运行；
- 隔离性(Isolation) : 隔离程度不同，会导致事件执行的结果不同；
- 持久性(Durability) : 修改后永久更新。



### 3.3 隔离的级别

#### 3.3.1 脏读（读未提交）

另一个事务未提交的变量也能读；

不需要视图，直接读到最新数据；



#### 3.3.2 读提交

只有另一个事务提交了以后，才能读到变量的改变；

在每一句sql执行时创建视图；



#### 3.3.3 可重复读

在事务提交之前，所读到的数据是一致的；

在事务开始的时候就创建视图；



#### 3.3.4 串行化

在事务读写时加上锁，另一个事务想要执行必须等待锁解除。



#### 3.3.5 一个实例

![img](https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png)

答案：

```c++
若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
    
若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
    
若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
    
若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。
```



### 3.4 事务的启动

事务的启动，一般可以分为自动启动和手动启动；

`set autocommit=0` 这行代码会导致关闭自动提交，直到你主动commit 才会停止，可能导致意外的长事务；

长事务的坏处是：需要记录很长的回滚日志，可能浪费非常多的存储空间，并且会占用锁资源，所以建议尽量避免长事务。

`set autocommit=1` 是避免长事务的方法之一。



## 4. 索引

### 4.1 索引的数据结构

innoDB采用 **B+树** ，B+树查找效率和磁盘读取效率综合较优；能减少单次查询的磁盘访问速度



### 4.2 索引的方式

1. 主键索引（集簇索引）：通过查询主键，直接得到整行数据；
2. 非主索引（二级索引）： 通过查询其他，来获得主键，再去查询主键；

尽量使用主键查询，并且在数据库设计时，可以尽量使用自增主键，这样就能在非主键索引的占用空间最小；

但如果是唯一索引，这样我们就不用考虑非主键索引的空间占用问题，直接设置就行了。



### 4.3 覆盖索引

建立索引，减少回表的次数，减少树的搜索，显著提升查询性能，是一种非常常规的优化手段；

#### 4.3.1 最左前缀原则

因为数据结构是**B+树**，所以只要满足最左前缀相同，就可以利用索引来加速搜索。

如图所示的张三的索引，就是一个一个字段的排序：

![img](https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg)



#### 4.3.2 建立索引的原则

1. 调整顺序，来达到多次复用索引的原则；
2. 调整空间，选择两个元素中空间较大的来单独建立索引（如果两者都需要建立索引）；



### 4.4 索引下推

 当一个语句有多个条件需要查询时，先通过查询索引，然后查询该语句在索引内的其他条件，如果满足先筛选后再进行回表操作，可以通过这样的手段来减少回表次数，提高资源利用效率。

![img](https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg)



## 5. 锁

### 5.1 全局锁

语法：` Flush tables with read lock (FTWRL)`；

全局锁的使用场景： 做全局备份的时候会用到，保证数据在备份时不被更改；

但是可能发生主从延迟和业务停摆的问题。

`–single-transaction`, innoDB官方的备份是这个命令，原理是开始备份时启动一个事务，备份失败全局回滚；



### 5.2 表锁

事先需要说明，只有引擎不支持行锁的时候，才会使用表锁，他的sql 语句是：

**lock tables … read/write**。

还有就是MDL（元数据锁）， 引擎会自动在进入表时创建MDL锁；

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

![img](https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg)

如图所示，因为事务没有提交，所以会锁住sc和sd。

因为所有对表的增删改差都需要申请MDL锁，c被锁住，后面也全部会锁住。

所以比较好的解决方式是，提交事务或者kill 长事务，然后再进行增删改查。

如果kill不起作用，可以选择等待若干秒后继续下一个事务，不影响 后面的进程。

```
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```



### 5.3 行锁

#### 5.3.1 两阶段锁协议

行锁并不是使用完锁以后立即释放，而是等待事务提交以后才会释放。

比较好的设计方式是：把最可能影响并发度的行放在事务的后面。



#### 5.3.2 死锁检测和死锁

死锁就是竞争资源而导致的资源循环依赖。

当发生死锁的时候，通常有两种比较好的方式：

1.  一个就是设置等待时间，直到超过等待时间。
2. 另一个就是打开死锁检测。当发现死锁的时候，回滚释放资源。



