# 图解计算机网络

------

> 《图解网络》写的网络知识主要是**面向程序员**的，因为小林本身也是个程序员，所以涉及到的知识主要是关于程序员日常工作或者面试的网络知识。
>
> 非常适合有一点网络基础，但是又不怎么扎实，或者知识点串不起来的同学，说白**这本图解网络就是为了拯救半桶水的同学而出来的**。
>
> 因为小林写的图解网络就四个字，**通俗易懂**！



## 1. 基础

### 1.1 TCP/IP网络模型

#### 1.1.1 应用层

应用层就是负责把数据传输给传输层，为用户提供应用功能，但并不提供传输功能。工作在用户态。

#### 1.1.2 传输层

传输层及以下工作在内核态，有两个传输协议：**TCP和UDP**。

传输层的作用是为应用层提供网络支持。

传输层在**发送**时，对超大数据会分段，成为TCP段，然后加上TCP头，进入下一层。

**在接收时，** TCP会根据端口号，来传输给具体的应用。



#### 1.1.3 网络层

网络层负责传输，将TCP报文段封装成帧，添加上IP头，具有寻址和路由的功能。

相关概念：

- 网络号（寻址匹配）
- 主机号
- 子网掩码



#### 1.1.4 网络接口层（链路层）

为网络层提供链路级别的服务。

加上MAC头，然后在以太网中传输。





### 1.2 封装格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)





### 1.3 从输入网址到网页显示全过程

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)



#### 1.3.1 解析URL

解析URL地址，然后生成web服务器的请求，封装成为HTTP请求；

![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)



#### 1.3.2 根据DNS服务器找到IP地址（真实地址查询）

访问DNS服务器，从根服务器一直访问到权威服务器，然后获取目的IP地址；

如图是DNS解析过程：

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

**如果有缓存（服务器，操作系统，hosts文件），就可以直接获取IP地址。**



#### 1.3.3 协议栈

浏览器通过socket库，调用操作系统的协议栈，然后知悉下一步该如何操作。



#### 1.3.4 TCP协议

通过TCP协议，封装成TCP报文，通过三次握手，让服务器与客户端建立连接（**双向通信**）；

TCP头部中有端口号和目的端口号；

![TCP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)



#### 1.3.5 IP协议

IP头中有源IP地址和目的IP地址。

封装上IP头，查询路由表，获知自己的源IP地址；

![IP 层报文](C:\Users\OMEN\Desktop\Note\计算机基础\17.jpg)



#### 1.3.6 MAC

封装上IP头后，需要加上MAC头，来封装成MAC帧。

获取目的MAC地址的方法：

- 查询ARP缓存；
- 用ARP协议广播；

![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)



#### 1.3.7 网卡

网卡接受到数字信息后，加上头尾：

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

然后将数据包转为电信号，从网卡出去；



#### 1.3.8 交换机

交换机没有MAC地址，但是有MAC地址表；

交换机接受电信号后，转换为数字信息，然后检验数据是否完整，如果完整就可以检查自己的**MAC地址表**，继续转发；

![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)



#### 1.3.9 路由器

路由器有MAC地址和IP地址，所以叫三层设备；

路由器的工作过程：

1. 接受传输给自己的数据；
2. 然后查询路由表查看接收方MAC地址，如果不是自己的直接丢弃；
3. 接收完成后，去掉MAC头；
4. 根据IP头重写MAC头；
5. 如果网关为空，则到达目的地，否则转发到网关地址；

总结：IP地址始终不变，只有MAC地址在改变（通过ARP协议不断查询）。



#### 1.3.10 服务端与客户端的总结

![网络分层模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)





## 2. HTTP篇

### 2.1 HTTP概念

中文全称：超文本传输协议

概述：



## 3. TCP篇

### 3.1 TCP格式

源端口：

目的端口：

序列号：

确认应答号：

控制位：

- ACK：
- RST：
- SYN：
- FIN：

什么是TCP：三大特点

四元组：



#### 3.1.1 TCP和UDP的区别

1. 连接：
   - TCP面向连接，需要建立 连接才能传输数据
   - UDP不需要连接，直接传输数据；
2. 服务对象：
   - TCP点对点传输，只能一对一；
   - UDP可以一对一，也可以一对多，多对多。
3. 可靠性：
   - TCP交付可靠传输，保证数据的完整性和正确性，按序到达；
   - UDP尽最大努力传输和交付。
4. 拥塞控制，流量控制：
   - TCP有流量控制和拥塞控制，能根据网络情况调整发送速率；
   - UDP没有，速率不会改变；
5. 首部开销：
   - TCP至少20字节，如果用了可选字段则更多；
   - UDP固定八个字节。
6. 传输方式：
   - TCP字节流传输，没有边界，但是保证顺序和可靠；
   - UDP一个包一个包的发送，可能丢包和乱序。
7. 分片不同：
   - 分片是在TCP层分，然后也在TCP层组装，如果中途丢失一小部分，只需要重传那个分片；
   - UDP则在IP层分片和组装。



#### 3.1.2 TCP与UDP的应用场景

- TCP因为可靠交付，所以可以应用于FTP文件传输和HTTP/HTTPS，
- UDP面向无连接，所以通常用于DNS，SNMP，视频音频，广播通信。



#### 3.1.3 TCP长度计算

**IP长度+IP首部+TCP首部。**



#### 3.1.4  TCP可以使用同一个端口

因为TCP和UDP主要使用不同的应用程序，通过网络层以后直接根据首部数据区分开来，所以可以使用同一个端口。



### 3.2 TCP连接的建立

开始：都处于close状态，然后  端开始监听；

#### 3.2.1 三次握手的第一个报文

客户端的操作：客户端发送一个SYN报文，初始化SYN报文的序列号；

报文中的数据：SYN标识设为1，然后报文序列号设置为序列号，不带任何数据

客户端的状态：SYN_sent状态



#### 3.2.2 三次握手的第二个报文

服务端的操作：接收到客户端发送的SYN报文后，初始化自己的SYN和ACK报文的序列号，然后将客户的序列号+1后返回到应答号；

报文中的数据：SYN和ACK标志位设为1，然后将序列号和应答号全部填入到报文中；

服务端的状态：SYN_RECVD状态



#### 3.2.3 三次握手的第三个报文

客户端的操作 ：发送一个ACK报文，初始化序列号，然后将服务端的序列号+1填入到应答号中；

报文中的数据：ACK设为1；

客户端的状态：established状态

服务端的状态：established状态





### 3.3 三次握手的原因

#### 3.3.1 阻止重复历史连接的初始化（主要原因）

当网络堵塞，重新发送SYN连接时，如果之前的报文先到或者后到，因为服务端返回的应答号不同，就会让客户端发送一个RST请求，让客户端释放上一次连接请求的资源。

两次握手显然不能做到这一点，咋成历史连接的重复初始化，资源浪费。

#### 3.3.2 同步双方的序列号

可靠传输的重要工具：序列号；

1. 根据序列号，去掉重复的数据；
2. 根据序列号，调整接受包的顺序；
3. 通过ACK报文，知道对应包是否收到。

#### 3.3.3 避免资源浪费

没有第三次握手，如果两次握手，因为没有客户端返回的消息，所以每收到一个SYN请求，就会直接建立连接，重复链接就建立了，会造成资源的极大浪费。



#### 3.3.4 小结

两次连接： 造成资源浪费，无法同步初始化双方的序列号。

四次链接：有理论更小的可能，不需要再额外多一次连接。



### 3.4 每次建立TCP连接要求的序列号都不一样

#### 3.4.1 防止历史报文被下一个相同四元组的连接接收（主要方面）

如果因为网络问题第一个包被阻塞了，当继续传输过后，已经建立连接的包再次受到这个报文可能导致数据紊乱。

#### 3.4.2 为了安全性，防止被伪造报文



### 3.5 IP层会分片，那么为什么TCP还需要MSS

#### 3.5.1 MTU

IP头+TCP头+数据部分的最大长度；

一般为1500字节。

#### 3.5.2 MSS

数据的最大长度；

在TCP层有用，SYN请求中会有规定。



如果在TCP分片过后，只要组装的数据没有超过MTU就不需要进行IP层的分片。



### 3.6 各个握手丢失会发生的事情

#### 3.6.1 第一次握手丢失

第一次握手的SYN请求发送以后，客户端会进入SYN—sent状态，如果超时没有收到来自服务端的SYN—ACK请求，就会重发一个序列号一样的报文。

**超时重传**





#### 3.6.2 第二次握手丢失

第二次握手丢失的情况：

客户端在SYN—sent状态，服务端在SYN—RCVID状态，双方因为没有收到应答报文，所以都会触发超时重传机制。



#### 3.6.3 第三次握手丢失

迟迟没有收到ACK报文，服务端超时重传。

ACK是不会重传的，如果丢失，由对方重发。



### 3.7 TCP断开连接

#### 01 四次挥手的过程

双方都可以断开连接：

一客户端关闭连接为例：

- 客户端发出FIN报文给服务端，并进入FIN_WAIT1， 服务端收到FIN报文以后，返回一个ACK报文，然后进入CLOSED_WAIT状态，
- 客户端收到ACK报文以后进入FIN_WAIT2状态
- 等服务端处理完事务后，发送一个FIN报文给客户端，客户端收到FIN并返回一个ACK报文给客户端，并进入TIME_WAIT状态；
- 服务端收到ACK报文后直接关闭连接，并进入CLOSED状态；
- 客户端在等待2MSL后关闭连接，进入closed状态；



#### 02 为什么需要挥手四次

客户端需要等待数据发送完才会再次发送FIN请求。



#### 03 第一次挥手丢失

第一次挥手过后，客户端进入FIN_WAIT1状态，丢失后 进入超时重传，如果超时重传多次并超过最大时间以后，客户端直接断开连接；



#### 04 第二次挥手丢失

第二次挥手是客户端的ACK请求，在这之后进入CLOSE_WAIT状态；

而客户端重传多次FIN请求以后，如果超时，直接关闭连接；



#### 05 第三次挥手丢失

第三次挥手是服务端的FIN报文，在此之后，客户端进入CLOSE_WAIT状态，如果迟迟收不到报文，就会不断重发，如果超过时间限制，就会直接close，而此时客户端因为进入了FIN_WAIT2状态，如果一直收不到FIN报文，超过时间先之后，也会直接断开连接。

#### 06 第四次挥手丢失

客户端发出ACK请求后直接进入到TIME_WAIT状态，但因为服务端收不到FACK，就会不断重发FIN，不断重置2MSL，直到超过了服务端的限定重发次数；

2MSL后，客户端关闭；



### 3.8 Time_Wait

#### 01 为什么是2MSL

MSL：报文最大生存时间；

TTL：IP首部经过路由器的数量，每经过一个就-1；



linux中TTL一般为64， MSL一般为30s，经过64次就丢失，超过30s也丢失。



2MSL的原因：

1. 可能网络中还存在发送方的数据包，发送过去再回复回来最多需要2msl，
2. 至少允许报文丢失一次；

#### 02 为什么有TIME_WAIT状态

- 防止相同四元组接收了历史连接的数据，导致数据混乱；
- 保证被动关闭方能够正确关闭连接；



#### 03 TIME_WAIT过多的危害

- 客户端：客户端的TIME_WAIT过多，会导致端口资源被占用，目的ip+目的端口的服务端连接就不能建立了；
- 服务端：占用系统资源，但不会影响端口；



#### 04 客户端存在太多TIME_WAIT的状态

1. 没有使用长连接；
2. 长连接超时
3. 长连接数量达到上限



### 3.9 重传机制

#### 01 超时重传

RTT：往返时延，从发送到接收到ACK报文的时间；

RTO：超时重传时间，应该略大于RTT

超过两次发送依然没有收到回复，说明网络环境比较差，不应该重复发送，此时应该使用另一种机制：快速重传；



#### 02 快速重传

收到三个相同的ACK报文，重传对应SYN报文；



#### 03 SACK机制

每次ACK报文都包含了SACK，这样就能比较方便检测缺失哪一段报文；



### 3.10 滑动窗口机制

TCP应答机制的缺点：如果往返时间过长，会导致效率十分低下，于是引入了滑动窗口机制，窗口的大小就是可以连续发送的TCP请求。

可用窗口大小：窗口大小-最后一个发送的窗口指针+第一个窗口指针；



发送方的传输窗口总是约等于接收方的传输窗口，因为传输窗口的大小由接收方决定，接收方如果处理数据的速度变更， 可能导致窗口变更，并且进而影响到其余窗口。 



### 3.11 流量控制

不断调整窗口的大小，但是其中存在一个潜在的死锁危险:

如果发送方的窗口非0报文丢失，就会造成死锁，此时发送方在等待窗口非0报文，接收方又在等待接收方的消息，造成了死锁。

解决方案：接收方在关闭窗口一定时间后，发送窗口探测报文；

超过三次窗口依然关闭，就会直接发送RST断开连接。



#### 01 窗口糊涂综合征

每次接收发送小数据，但TCP头有40字节，非常浪费资源，

解决方案如下：

1. 发送方不发送小数据；
2. 接收方不接受小窗口：小于一定窗口（min）直接关闭窗口；



### 3.12 拥塞控制

用一个拥塞窗口来控制，如果网络拥塞，窗口减小，反之增大；

判断拥塞：是否在规定时间内接收到了发送方的数据，如果没有，就判断为拥塞；



**四个控制算法如下**：

#### 01 慢启动

接收方每收到一个ACK确认报文，就会增加 cwnd +1， 呈指数增长；

慢启动门限：当达到门限时，启动拥塞避免算法；



#### 02 拥塞避免算法

每收到一个ACK，就会增加 1/CWND；

如果一直增加，导致网络拥塞，触发了重传机制，就会进入拥塞发生算法；



#### 03 拥塞发生算法

1. 超时重传的拥塞算法：

   ssthresh设为cwnd/2，然后将cwnd重置为1；

2. 快速重传的拥塞算法：

   cwnd设为原来的一半，然后ssthresh设为cwnd，进入快速恢复算法；



#### 04 快速恢复算法

拥塞窗口=ssthresh+3；

重传丢失的数据包，如果收到ACK就cwnd+1；

收到新的ACK后，把cwnd设为第一部中的ssthresh；



### 3.13 



## 4. IP篇

### 4.1 IP地址基础

#### 4.1.1 有分类地址

分为ABC三类，主要通过IP地址的前几位来划分；

0xxx为A，

10xx为B，

110X为C，

1110为D，用于多播。

#### 4.1.2 无分类地址CIDR

特征：IP地址分为网络号和主机号，以此衍生出了子网掩码，除了主机号以外的部分全部||1，得到子网掩码，然后主机号全部调为0；

如何区分网络号和主机号：**最后的/n** 中的“ N ”代表的就是网络号的长度。



#### 4.1.3 子网划分

如何划分：将主机号中的一部分作为子网网络号，另一部分作为子网主机号。



#### 4.1.4 公有私有IP地址

**仅存在于有分类IP地址中**；

共有IP世界唯一，私有IP则可以重复。



#### 4.1.5 IP地址与路由控制

方式：通过网络地址进行路由控制，首先查看路由表中的缓存，如果查到了源IP地址，就通过缓存中的下一跳跳到下一个路由器。



#### 4.1.6 IP分片与重组

MTU：最大传输单元，在以太网中为1500字节。

如果超过 **MTU** ，就需要进行分片，网络层只负责分片，并且如果丢失，舍弃整个IP数据报，并不负责重组，由上层来重组。



### 4.2 IP协议相关技术

#### 4.2.1 DNS

域名的层级关系：从后往前，后面最大，根域名后面就是com顶级域名。

域名解析的流程：只问路，不带路。

从根服务器开始依次往下请求。



#### 4.2.2 ARP

ARP协议的工作过程：向自己的网域内部发送广播，用通过IP询问MAC地址。



RARP协议：相反，用MAC地址询问IP地址。



#### 4.2.3 NAT

原理：将私有地址转换为共有地址，解决ipv4地址短缺问题。

NAPT：将一个局域网内的私有地址转换为同一个公有地址，通过端口号来区分。

缺点：

1. 转换和计算需要成本；
2. 无法将共有转换为私有；
3. 如果路由器重启了， 所有TCP连接将断开。



#### 4.2.4 ICMP

功能：IP传输发生错误时，将错误原因报告。

类型：查询报文和差错报文；



#### 4.2.5 IGMP

作用范围：在最后一跳路由器和主机之内；

工作机制：

1. 常规查询与响应：间隔特定时间，路由器向特定组播ip地址发送IGMP报文，在组播组内的主机响应，记录到IGMP路由表。
2. 离开组播组：主机向路由器发送IGMP离开报文，然后路由器间隔特定时间，向组播组内所有主机发送消息：
   - 如果有响应：就继续向组播组内转发消息；
   - 如果无响应：删除路由表中记录的消息，并且不再响应。



### 4.3 PING的工作原理



#### 4.3.1 ICMP协议

全称：互联网控制网络协议；

本质：IP数据包；工作在网络层。



ICMP类型：0和8代表：0代表回应，8代表发送请求。

标识符：标识进程。

序号：标识序号， 用以判断信息是否完整。



目标不可达消息：类型为：3



目标不可达类型：

11 ：超时消息；





#### 4.3.2 ping工作流程：

源主机： 组装一个ICMP报文，使用的协议是：ICMP ，请求类型是：8 ，协议号是：1（ICMP） ，用  IP数据报 封装， 在报文的数据部分插入时间。接下来加入MAC头，用 ARP协议来获取目的MAC地址，然后通过MAC地址发送给下一跳;

目的主机：如果mac地址匹配就接受该数据报，并且由IP层取出相应的信息，然后发送给上一层，然后再组装一个类型为0的回应ICMP给目的主机，其他步骤基本一致。



### 4.4 断网能ping通127.0.0.1



#### 4.4.1 什么是127.0.0.1

地址类型：



#### 4.4.2 ping

本质是：

调用的协议是：

与TCP发数据的区别是：



#### 4.4.3 断网了为什么能ping通？

目的IP是本地的情况下，会将信息传送给：本地网卡 ，然后将数据推给一个链表，并触发： **软中断**， 有一个内核进程就会取出该信息， 然后层层往上传递给应用层。



#### 4.4.4 各种“本地地址”

127.0.0.1 ：回环地址。

localhost：本质是一种域名，但是他的默认解析地址为：127.0.0.1；

0.0.0.0：listen的时候代表本机的所有IP地址，connect时不能用；

本机地址：ping的时候都会走本地网卡，直接返回给应用。

 











