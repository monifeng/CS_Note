# Effective C++ 读书笔记

> Wisdom and beauty from a very rare combination.



## 01 视C++为语言联邦

C++可以视为一个语言的联邦。

最初C++的设计是带有类的C语言（C with classes），直到后来，才开始慢慢扩充，并且对于不同的次语言部分，有不同的高效的使用方法。

### 1.1 C in C++

主体部分，任然是C语言，C语言中绝大多数部分C++同样可以使用，比如数组，指针；因为主体是C， 所以使用这一部分时，值传递非常有用。



### 1.2 OOP C++

这一部分就是C++语言中面向对象的部分，类，封装，继承，多态，以及虚函数...

在这一部分时，因为存在用户自定义的类，所以在传递值的时候，我们需要更多的使用引用传递。



### 1.3 Template C++

模板知识，这部分就是C++中比较创新的部分，提高了C++的复用性；这里也是使用引用传递更加稳妥和高效。



### 1.4 STL C++

这部分的C++语言，因为更多的采用了C中的指针等来设计，所以值传递又成了主旋律。



## 02 用编译来替代预处理

在使用C++语言时，尽量用const， inline， enum 来替代#define；

因为`#define` 是是直接提交给了预处理器，当你用#define 来定义变量时，往往不会进入符号表，而是简单的字符串替换。

我们可以用const 修饰变量，来达到define一个变量一样的效果；

也可以使用inline 来修饰一个函数，达到和define一个函数一样的效果；

更可以使用enum 来替换类中的define常量。





## 03 尽可能使用const

const分为 物理常量和逻辑常量；

物理常量指的是不能修改任何函数内的非常态成员，任何一个bit都不能被修改；

逻辑常量指的是可以在某些情况下修改一些bits，这时可以为总是被修改的常量加上

`mutuble` 这个属性，意为可变的；

为一些返回值加上const可以在编译阶段处理掉一些不合法的操作；

当const成员和非const成员有实质等价的时候，选择用non-const调用const成员，

原因是：const意味着你声明你不会改变他，但正向调用可能会破坏你的声明，这是一个危险的行为；

反向调用需要我们进行两次类型装欢，先用static_const 转换成const 对象，然后调用const 成员，再转为non_const 对象，这样就完成了转换。



## 04 确定对象使用前已经被初始化

1. 在声明变量的时候，一定要先初始化；
2. 如果是用户自定义的对象，构造函数一定要使用成员初值列来替代赋值操作，并且该初值列的次序最好是成员的次序；
3. 用local static 来替代non_local static，避免不同编译单元内初始化次序问题；

这里非常好的一个办法就是用一个成员函数来包含静态成员的声明，这样做的原因是，静态对象在首次遇上该对象的定义式时，**会初始化**。



## 05 C++默默编写的函数

在定义一个类时，即使你不写，编译器也会为你提供默认的函数：

1. 默认构造函数
2. 默认拷贝构造函数
3. 默认析构函数
4. 默认拷贝运算符

当你自己手写任意构造函数以后，就需要自己定义一个默认的构造函数，否则编译器会默认你已经放弃；



## 06 不想使用编译器默认函数就应明确拒绝

当你不想使用编译器默认的构造函数时，应该将那些函数声明为private，有一个很好的做法是：声明一个基类为Uncopyable， 然后让派生类继承这个基类：

> 需要注意的是：该基类要用的函数应为 `protect` ，而明确不使用的函数应为 `private` 

这样当一个其他类试图拷贝或者别的行为时，编译器将会拒绝。



## 07 为多态基类声明vitual析构函数

如果不是vitual析构函数，可能导致 **部分释放** 这样的问题出现，因为派生类如果没有 定义自己的析构函数，会调用基类的析构函数，导致派生类的成员可能并没有完全释放，倒是内存溢出或者资源浪费。

并且当一个类并不打算用作基类的时候，就不应该使用vitual析构函数，  原因是：虚析构函数导致了一个**vptr**的诞生，这会浪费许多内存，并且导致代码的可移植性降低。

> 例如C语言就并没有定义这个vitual函数；

重要心得：**只有当一个类有vitual函数时，才为他定义一个vitual析构函数**。



## 08 别让异常逃离析构函数

当调用析构函数出现异常时，我们可以用以下两种方法暂时解决这样的问题：

直接在析构函数中捕获异常，如果发现异常直接终止，或者直接记录然后跳过；

最不能做的就是让该异常逃出析构函数。否则将会导致未定义的错误。一个比较好的方式是：用一个函数来调用析构函数，并设置一个flag，然后再在析构函数中判断是否正确析构，否则进行上面两步操作。



## 32 确保public继承代表的是“is-a”关系

public 继承意味着 “is - a”关系，也就是说一个public继承的派生类一定是一个基类（可以在任意地方替换，例子：企鹅与鸟，长方形与正方体）。

但需要注意，某些时候我们不能按生活常识来写这些public继承，比如长方形修改自己的长宽，而鸟能飞，企鹅不能飞，这种情况可以单独写一个派生类或者单独写派生类的方法。



## 33 避免遮掩继承而来的名称

当发生继承的时候， 编译器在查找函数的时候会优先查找最近的（派生类-->基类-->作用域-->全局作用域……) 如果派生类重写了函数，基类的所有重载都会被覆盖。

比较好的解决方式是：using函数，让基类的函数在派生类的作用域内都可见。

```c++
using Base::mf1();
using Base::mf2();
```

如果是private继承，可以写一个转交函数，在函数内调用基类的函数（这样做的好处是可以只继承某个需要的重载）

```c++
vitual void mf1()
{	
	Base::mf1();
}
```



## 34 区分接口继承和实现继承

pure vitual（纯虚函数）只具体实现接口继承。也就是规定了派生类必须实现这个函数。

vitual（虚函数）可以具体实现接口继承和缺省方法继承。派生类可以不实现这个函数，也可以重写这个函数。

non-vitual（非虚函数）指的是不需要做任何修改，一般性大于特异性的函数。派生类中不需要做任何修改。



## 35 考虑vitual函数以外的函数

### 1. NVI手法

以public的函数包裹一个较低优先级的vitual函数，这样做的好处是：可以在该虚函数执行前后进行准备工作和清理工作。



### 2. Strategy手法

函数指针，tr1::function，另一个继承体系内的vitual函数来替换该vitual函数。



## 36 绝不重新定义继承而来的non-vitual函数

non-vitual函数是静态绑定的，当前是什么类型，就调用什么类型的函数。



## 37 绝不重新定义继承而来的缺省参数

缺省参数是静态绑定的，什么类型就使用什么类型的缺省参数。

当你对一个基类指针（实际指向一个public继承的派生类）重新定义了他的缺省参数并且调用这个函数时，会出现严重错误：**该函数使用了派生类的函数却调用了基类的缺省参数** ，比较好的解决方法是 **NVI** 手法，即定义一个non-vitual函数和一个纯虚函数，用这个non-vitual函数去调用纯虚函数，并且该纯虚函数设定一个缺省参数值，这样就可以解决缺省参数值的代码重复和代码依赖性过强的问题。



## 38 利用traits来萃取类型

在template编程中，我们希望在运行期获取类型，并且在运行期调用特定函数，

这里我们可以写两组函数：

1. 劳工 函数：专门写出针对不同类型参数的重载函数；
2. 工头函数： 调用不同类型的劳工函数，将参数传递给他们；



而这里要获得编译器类型，就需要我们写一个萃取类（traits classes） ，其中包含一个category的数据；
